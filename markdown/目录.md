[TOC]



## 1 JAVA 相关

### 1.1 JAVA 基础

#### 1.1.1 内存模型 (JMM)

工作内存对应着 JVM 运行时数据区的 JVM 栈,而主内存对应着 堆(线程不安全) 与 方法区(线程安全)

##### 1.1.1.1 主内存 与 工作内存

**Java 角度看内存**

![img](resource\jmm-memory.png)

**硬件角度看内存**

![img](resource\hardware-memory.png)

- 寄存器

  每个CPU 中都有一系列的 寄存器,CPU 在寄存器上计算操作要比内存中快的多.

- 高速缓存

  每个CPU 都会有一个CPU 的Cache 内存,CPU 访问Cache 的速度要快于访问内存的速度,慢于访问寄存器的速度.一般会分为多级,一级 cpu 独享,二级 或 三级 CPU 分组共享 或 全部共享

- 主存 多个CPU 共享.访问速度慢.

CPU Cache 伪共享问题

##### 1.1.1.2 内存间的原子性操作

|        |      |          |                                                   |
| ------ | ---- | -------- | ------------------------------------------------- |
| lock   | 锁定 | 主内存   | 变量处于线程独占状态                              |
| unlock | 解锁 | 主内存   | 变量从锁定状态释放                                |
| read   | 读取 | 主内存   | 将主内存变量传递到工作内存,便于后续load           |
| load   | 载入 | 工作内存 | 将从主内存read 操作的变量放入到工作内存           |
| use    | 使用 | 工作内存 | 将工作内存中的变量传递给执行引擎                  |
| assign | 赋值 | 工作内存 | 将执行引擎中的值付给工作内存中的变量              |
| store  | 存储 | 工作内存 | 将工作内存中的变量传送到主内存,便于后续write 操作 |
| write  | 写入 | 工作内存 | 将工作内存store操作的变量存入到主内存中           |

##### 1.1.1.3 内存间的交互规则

1. 从主存读,要顺序执行 read,load 操作
2. 向主存写,要顺序执行 store,write 操作
3. 1,2 中的要求的顺序,非连续  如:read a, read b,load a,load b
4. read,load 或 store,write 必须成对出现,不能单独出现.
5. 不允许线程丢弃它的最近assign 操作
6. 不允许线程把没有发生过assign 操作的数据同步到主内存
7. 新变量只能在主存中产生,不允许在工作内存中使用未经初始化的变量
8. 一个变量同一时刻只允许一条线程进行lock 操作,但lock,unlock 可以被同一个线程执行多次.
9. 对一个变量进行lock操作,会清空工作内存中此变量的值,后面需要重新load  或 assign 操作初始化变量的值
10. 线程不能unlock 未被lock 锁定的变量,也不能unlock 被其他线程锁定的变量
11. 执行unlock 前,必须把变量同步回到主存中 执行store write 操作.

##### 1.1.1.4 volatile 变量的特殊规则

volatile 特性是无法分配到寄存器中,**新值立即同步到主存中,每次使用前从主存中刷新.**

Java 中的运算并非原子操作.volatile 变量并发下并不一定安全

**volatile 修饰后,禁止指令重排优化**.普通变量仅仅保证在方法执行过程中,所依赖赋值结果的地方都能正确获取到结果.不能保证变量操作的顺序与代码中执行顺序一致.

##### 1.1.1.5 原子性 可见性 有序性

**原子性**:基本数据类型访问读写 是原子的.read load write store use assign .更大范围的原子性需要借助java 的 lock 与 unlock 来实现.

**可见性**:volatile 可见性,synchronized 可见性(参考 1.1.1.3 中规则11 ),final 可见性(值无法改变)

**有序性**:同一线程内 所有的操作都是有序的,在其他线程观察,操作是无需的,可以使用volatile 与 synchronized 来保证线程间的有序性.

##### 1.1.1.6 happens-before

1. 程序次序规则:同一线程内按照程序代码顺序执行
2. 管程锁定规则:一个unlock操作,先行发生于后面的lock
3. volatile 变量规则:对一个volatile变量的写操作先行发生于后面变量的读操作
4. 线程启动规则:start 方法,发生于线程的第一个动作
5. 线程终止规则:线程的所有操作都先于线程的终止动作
6. 线程中断规则:对线程interrupt 方法的调用,先于 被中断线程检测到中断的发生
7. 对象终结规则:对象的初始化操作 先行与 finalize 操作
8. 传递性:如果A 先行与 B,B先行于C 那么A 先行于C

#### 1.1.2 Java 基本类型说明

JAVA 基本数据类型有八种:boolean,byte,short,int,long,double,float,char

> 在JAVA中,boolean 的值只有两种可能 true/false.JVM显然不能直接使用 true/false 标识boolean 类型
>
> 在JVM 中,boolean 的类型被映射成了int 类型, true 用 1表示,false 用0表示.

Java 基本类型说明

| 类型    | 值域                | 默认值   | 虚拟机内部符号 |
| ------- | ------------------- | -------- | -------------- |
| boolean | {false,true}        | false    | Z              |
| byte    | [-128,127]          | 0        | B              |
| short   | [-32768,32767]      | 0        | S              |
| char    | [0,65535]           | '\u0000' | C              |
| int     | [-2^31,2^31 -1]     | 0        | I              |
| long    | [-2^63,2^63 -1]     | 0L       | L              |
| float   | ~[-3.4E38,3.4E38]   | +0.0F    | F              |
| double  | ~[-1.8E308,1.8E308] | +0.0D    | D              |

**基本类型在栈上占用空间的大小:**

栈帧有两个主要组成部分,**局部变量区,字节码的操作数栈.**这里的局部变量是广义的,除了普通的局部变量,还包含实例方法的**"this指针"**以及方法所接收参数.

在JVM 规范中,局部变量区等价于一个数组,并且可以用正整数来索引.除了long double 值用两个数组单元存储,其他基本类型以及引用类型的值均占用一个数组单元.

说明,boolean ,byte short char 这四种类型,在栈上用的空间和int 是一样的,和引用类型也是一样的.因此,在32位HotSpot 这些类型占用**4个字节**,在64位HotSpot 占用**8个字节**.

注意,这种情况仅存在与局部变量中,而并不会出现在存储于对堆中的字段或者数组元素上.对于byte,char,short 这三种类型的字段或者数组单元,它们在堆上占用的空间分别为一字节,两字节,两字节,与类型匹配.

Java 基本类型的加载

JVM 的算术运算几乎全部依赖于操作数栈.也就是说,我们需要将堆中的 boolean,byte,char 以及 short 加载到操作数栈上,而后将栈上的值当做int 进行运算.

对于 boolean 与 char 这两个**无符号类型**来说,加载伴随着零扩展(值在低位,高位填充零)

对于byte,short 来说,加载伴随着符号扩展,(保持符号位不变,低字节为值,高字节填充零)

#### 1.1.3 方法重载 与 重写

**方法重载**:

同一类中,方法名相同,参数类型不同(继承关系也算)

​	重载方法在编译时即可确认调用,过程有如下阶段:	

1. 不考虑自动拆装箱,可变长参数选取重载方法
2. 1步骤没找到,允许自动拆装箱,不允许可变长参数 选取重载
3. 2步骤没找到,允许自动拆装箱,允许可变长参数 选取重载.

如果在同一阶段找到了多个适配方法,那么会在其中按照形参的集成关系 来选取.

**方法重写**:

子类中定义与父类中同方法名,参数的方法

若子类重写父类的静态方法,子类中会隐藏父类的静态方法

若子类重写了父类的非静态,非私有方法,那么子类重写了父类的该方法.

注:重写是Java 多肽的一种重要体现方式.

#### 1.1.4 异常

**异常处理的两种方式:**

1. 抛出异常	抛出异常使用**throw** 关键字
2. 捕获异常    捕获异常使用 **try**{}**catch**(){}**finally**{} 三种代码块

**异常的基本概念:**

在JAVA 语言规范中,所有异常都是Throwable类或者子类的实例,Throwable 有两大子类.

1. Error     一般抛出Error 时,执行状态已经无法恢复,需要终止线程甚至是终止虚拟机.
2. Exception  程序需要捕获并且处理的异常

**Exception 划分:**

1. 编译期异常

   需要使用try,catch显示的捕获或者throws 关键字在方法声明中标注

2. 运行期异常

   RuntimeException

异常实例的构造十分昂贵,因为在构造异常实例时,JVM需要生成该异常的**栈轨迹** .该操作会注意访问当前线程的栈帧,并且记录下各种调试信息,包括栈帧所指向方法的名字,方法所在类,文件名,以及在触发异常的代码行数.(在生成栈轨迹时,JVM会忽略掉异常构造器以及填充栈帧的JAVA方法-Throwable.fillInStackTrace)

**JVM 是如何捕获异常的**

在编译生成的字节码中,每个方法都会附带一个异常表,如下

```java
    Exception table:
       from    to  target type
           6     8    13   Class java/lang/Exception
           6     8    22   any
          13    17    22   any
          22    24    22   any
```

异常表中的每一个条目代表一个异常处理器,并且由from指针,to指针,target指针 以及所捕获的异常类型构成

这些类型的值是字节码索引,用以定位字节码

当程序触发异常时,JVM 会从上至下遍历异常表中的条目,当触发异常的字节码的索引值在某一行的from,to 范围内时,JVM 会判断抛出的异常与 该条目捕获的异常是否匹配,若匹配,JVM将控制转移至该条目target指针指向的字节码.

若遍历完所有异常条目,JVM 仍未匹配到异常处理器,那么会弹出当前方法对应的JAVA 栈帧,并且在调用者(caller)中重复上述操作.最坏情况下,JVM 需要遍历当前线程JAVA 栈上的所有方法异常表.

finally 代码块的编译比较复杂,当前版本JAVA 编译器的做法是复制finally 代码块的内容,分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出后中.

注:若catch 代码块中捕获了异常,并且触发了另一个异常,那么finally 捕获并且重新抛出的是新的异常,原有的异常会被忽略掉.

**JAVA7 语法糖**

try-with-resources 语法糖,用来隐式的释放资源:

​	在try 关键字后声明并实例化实现了AutoCloseable 接口的类,编译器将自动添加对应的close 操作.

#### 1.1.5 集合类框架

![img](resource\collection.png)

**Collection**: 基础集合接口,提供增删改查遍历等方法,没有定义元素间的位置或顺序.也没有规定是否有重复元素

**List**:继承Collection,是有顺序的集合,增加了根据索引进行操作的方法,实现类 ArrayList 基于数组实现.LinkedList 基于链表实现.前者随机访问快,移动慢,后者相反.

**Set**: 继承Collection,不含重复元素,主要实现类有HashSet(HashMap 实现),TreeSet(TreeMap 实现).

**Queue**:继承Collection ,FIFO 队列,在尾部添加,在头部查看,有一个特殊实现 PriorityQueue(堆实现)优先级队列

**Dqueue**:继承自Queue,表示双端队列.实现类有LinkedList 基于链表实现 与 ArrayDequeue 基于循环数组实现.

**LiknedHashMap**:可以按照插入顺序或者访问顺序访问(除了hash表外,还维护了一个双向链表,用来存储最近访问的元素,将最近访问元素后移).

注:除了Hashtable,Vector,Stack 以上所有的容器都不是线程安全的.可以使用Collections 下的synchronizedXXX 包装.或者使用java.util.concurrent 包下的类进行替换.

**fail-fast 快速失败 与 fail-safe 安全失败**

Iterator 的安全失败是基于对底层集合做拷贝.因此它不受元集合上修改的影响.java.util包下面的所有集合都是快速失败,而java.util.concurrent 包下面的所有类都是安全失败的.快速失败的类会抛出 ConcurrentModificationException 异常,而安全失败不会.

**HashMap**

在jdk1.8版本之前. 实现是数组+链表.在1.8版本上引入了红黑树,进行优化.

基于数组加链表的结构,受限于 hash 函数实现.很难达到元素的均匀分布,即当HashMap 中存在大量元素时,在hash 后,可能恰巧在一个桶中的元素过多.这个桶下就会存在一个长链表.检索需要O(n).完全失去了优势.基于此,引入红黑树.通过O(logn)来优化此问题.

![img](resource\hashmap.png)

 * 允许 key value 为null,不保证访问顺序
 * fail-fast 并发操作失败 ConcurrentModificationException
 *	initial capacity  hash map bucket 的数量
 *  load factor		  hash map 多大时自动进行扩容(rehash)
 *  load factor 默认为0.75 来达到空间与时间平衡
 *  hash map 默认数据结构是 数组加链表.当链表中的元素变多时,会将其转化成 红黑树.
 *  红黑树中元素节点较小时,会退化成链表. 转化红黑树大小为8 ,退化链表大小为6

详细源码解读,参考 java/source code/java/util/HashMap.md

**ConcurrentHashMap**

**LinkedHashMap**



#### 1.1.* JDK 工具

|        |                                                           |
| ------ | --------------------------------------------------------- |
| jps    | 查看系统内所有JVM 进程                                    |
| jstat  | 收集jvm 各方面的运行数据                                  |
| jinfo  | 显示jvm 配置信息                                          |
| jmap   | 生成虚拟机内存快照 和 heapdump 文件                       |
| jhat   | 分析heapdump 文件,建立一个http 服务器,通过浏览器分析结果. |
| jstack | 显示虚拟机线程快照                                        |



### 1.2 Guava 基础

### 1.3 并发



#### 1.3.1 锁相关

##### 1.3.1.1 悲观锁 与 乐观锁

**悲观锁**

​	当一个线程,在获取一个资源不可用的时候,就将cpu 让出.并将当前线程进入阻塞状态,让出cpu 资源,当代资源释放. 如 synchronized 的重量级锁.	

**乐观锁**

​	假设没有冲突去完成某项工作.若冲突失败就重试,知道成功.当数据竞争不严重时,乐观锁效果更好.

悲观者与乐观者的做事方式完全不一样，悲观者的人生观是一件事情我必须要百分之百完全控制才会去做，否则就认为这件事情一定会出问题；而乐观者的人生观则相反，凡事不管最终结果如何，他都会先尝试去做，大不了最后不成功。这就是悲观锁与乐观锁的区别，悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据。

##### 1.3.1.2 Synchronized

###### 1.3.1.1.1 基础原理

Synchronized 关键字可以对程序进行加锁,可以 声明代码块,或直接标记静态方法与实例方法.

**synchronized 声明代码块**

当声明synchronized 代码块时,编译而成的字节码会包含 `monitorenter` 与 `monitorexit` 指令.这两种指令会消耗操作数栈上的一个引用类型的元素(synchronized 关键字括号内的引用),作为所要锁操作的对象.

从字节码可知,synchronized 包含一个monitorenter以及多个monitorexit指令.因为JVM 要确保获得的锁在正常执行路径,以及异常执行路径都能解锁.

**synchronized 标记方法**

当用synchronized 标记方法时,在字节码中方法的访问标记包括ACC_SYNCHRONIZED.该标记标识在进入该方法时,JVM 需要进行monitorenter 操作.而再退出该方法时,不管是否正常返回,还是向调用者抛异常.JVM 均需要进行monitorexit操作.

当**synchronized**修饰方法时有如下两种情况:

1. 修饰实例方法		锁对象等同于this
2. 修饰公共方法        锁对象等同于Class 实例.

关于monitorenter 和monitorexit 的作用:

> 抽象理解成每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针.
>
> 当执行monitorenter时,如果目标锁对象的计数器为0,那么说明没有被其余线程持有,在这个情况下,JVM 会将该锁对象的持有线程设置为当前线程,并且将其计数器加1.
>
> 若锁对象的计数器不为0时,如果锁对象的持有线程是当前线程(锁重入),那么JVM 将其计数器加1,否则需要等待,直至持有线程释放该锁
>
> 当执行monitorexit 时JVM 将锁对象的计数器减1.当计数器减为0时,标识该锁已经被释放掉了.

###### 1.3.1.1.2 Mutex Lock

监视器锁(Monitor)本质是依赖于底层的操作系统的Mutex Lock(互斥锁)来实现的.每个对象都对应于一个`互斥锁`标记,这个标记用来保证在任一时刻,只能有一个线程访问该对象.

**互斥锁**

用于保护临界区,确保同一时间只有一个线程访问数据.对共享资源的访问,先对互斥量进行加锁,如果互斥量已经上锁,调用线程阻塞,直到互斥量被解锁.在完成了对共享资源的访问后,要对互斥量进行解锁.

**Mutex 的工作方式**

![img](resource\mutexlock.png)

1. 申请mutex
2. 如果申请成功,持有mutex
3. 如果申请失败,进行spin 自旋.spin 的过程就是在线等待mutex,不断发起mutex gets ,直至获得mutex 或者到达 spin_count 限制为止
4. 依据工作模式的不同选择yield 或 sleep
5. 若达到sleep 限制 或 被主动唤醒  或 完成 yield ,重复1~4 步骤,知道获取mutex

由于Java 的线程是映射到操作系统的原生线程上的,如果要阻塞或唤醒一条线程,都需要操作系统来帮忙完成,需要从用户态转换到核心态中.这个状态转换需要耗费很多cpu 时间.所以synchronized 是java 中的一个重操作.为了避免这个过程.在JDK1.6版本中开始,JVM 对synchronized 进行了优化.

###### 1.3.1.1.3 Java 对象头-Mark word  

以32位JDK 为例.展示运行期间Mark Word 中的存储数据锁标志位变化

![img](resource\markword-lock.png)

###### 1.3.1.1.4 Synchronized 优化

锁一共有四种状态:**无锁**,**偏向锁**,**轻量级锁**,**重量级锁**

synchronized的执行过程： 
1. 检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁 
2. 如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1 
3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。 
4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁 
5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 
6. 如果自旋成功则依然处于轻量级状态。 
7. 如果自旋失败，则升级为重量级锁。

**无锁** 

​	锁对象的标记字段 最后三位为 **001**.

**偏向锁**

大多数情况下,锁不仅不存在竞争.从始至终只有一个线程请求某一锁.

在线程进行加锁时,如果该锁对象支持偏向锁,通过CAS 操作,将当前线程的地址记录在锁对象的标记字段中,并且标记字段的最后三位设置为**101**.

在接下来的运行过程汇总,每当有线程请求这把锁,JVM 只需要判断锁对象标记字段中最后三位是否为101,是否包含当前线程地址,以及epoch 值是否和锁对象的epoch 值相同,如果都满足当前线程持有该偏向锁,可以直接返回.不需要进行CAS 操作来加锁 与 解锁.减少了轻量级锁的执行路径.

偏向锁加锁:

1. 访问Mark World 中偏向锁是否为1(倒数第三位),以及锁标志位是否为 01,确认可偏向状态
2. 若为可偏向状态,判断标记字段中记录的线程ID 是否是当前线程,是的话直接执行5同步逻辑,否则继续判断
3. 若标记字段中记录的线程ID 不是当前线程,则通过CAS 方式获取锁.如果获取成功,则更新锁对象中的线程ID 为当前线程.执行5同步逻辑.否则执行4
4. CAS 获取偏向锁失败,代表有锁竞争(CAS 偏向锁失败说明至少有过其他线程曾经获得过偏向锁.因为线程不会主动释放偏向锁).当线程到达全局安全点时,会首先暂停拥有偏向锁的线程,然后检查持有偏向锁的线程是否存活.若线程不处于活动状态,则将对象设置成无锁状态(标志位`01`),然后重新偏向当前线程.如果线程还存活.撤销偏向锁后升级到轻量级锁状态(标志最后两位为00).此时轻量级锁由原有持有偏向锁的线程持有.继续执行同步代码.而正在竞争的线程会进入自旋等待获取该轻量级锁.
5. 执行同步代码.

偏向锁解锁:

​	参考获取过程步骤4,偏向锁使用了一种等到竞争出现才释放偏向锁的机制,线程不会主动去释放偏向锁

关闭偏向锁:

​	偏向锁在 java 6/7 中是默认启用的.若确认程序中锁通常处于竞争状态,可以通过 -XX:-UseBiasedLocking=false 关闭偏向锁.使程序默认进入轻量级锁状态.

epoch 值概念如下:

> 偏向锁的撤销:当请求加锁的线程与锁对象标记字段保持的线程地址不匹配时,(而且 epoch 值相等,如若不等,那么当前线程可以将该锁重偏向至自己)JVM 需要撤销该偏向锁.这个撤销过程非常麻烦,它要求持有偏向锁的线程到达安全点,再将偏向锁替换成轻量级锁.
>
> 若某一类锁对象的总撤销数超过了一个阈值(对应JVM 参数-XX:BiasedLockingBulkReiasThreshold 默认为20)
>
> 那么JVM 会将这个类的偏向锁失效.
>
> 具体做法是每个类中维护一个epoch 值,可以理解为第几代偏向锁,当设置偏向锁时JVM 需要将该epoch 值复制到锁对象的标记字段中.在宣布某个类的偏向锁失效时,JVM 需要将该类的epoch 值加1,标识之前那一段偏向锁已经失效.而新设置的偏向锁需要复制新的epoch 值.
>
> 为了保证当前持有偏向锁且已经加锁的线程不至于丢锁,JVM 需要遍历所有线程栈,找出该类加锁的实例并将它们标记字段中的epoch 加1,该操作需要线程处于安全点.
>
> 当总撤销数超过另一个阈值(对应JVM 参数-XX:BiasedLockingBulkRevokeThreshold 默认为40),那么JVM 会认为这个类已经不适合偏向锁,此时会撤销该类实例偏向锁,并且在后续的加锁过程中直接设置为轻量级锁.

**轻量级锁**

竞争不激烈的情况下(线程近乎交替执行同步块时),采用的锁方式:多个线程在不同的时间段请求同一把锁,没有锁竞争,这时JVM 采用轻量级锁代替重量级锁的阻塞与唤醒.

轻量级锁加锁

1. 代码进入同步块,如果同步对象锁状态为无锁状态(锁标志位 01,是否偏向锁为0),虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间,用于存储锁对象目前Mark Word的拷贝,官方称之为Displaced Mark Word.
2. 拷贝对象头中的Mark Word 复制到锁记录中
3. 拷贝成功后,虚拟机使用CAS 操作尝试将对象的Mark Word 更新指向为Lock Record 的指针,并将Lock Record 中的 owner 指针指向 对象头Mark Word.如果更新成功执行步骤4 ,否则执行步骤5
4. 如果3中更新成功了.那么线程就拥有了该对象的锁,并且将对象Mark Word 锁标志位设为 `00` ,表示此对象处于轻量级锁状态
5. 如果3中更新失败了.虚拟机首先会检查对象的Mark Word 是否指向当前线程栈帧,如果是说明当前线程已经拥有了这个对象的锁,那就可以继续执行同步代码块.否则说明多个线程竞争锁.进而膨胀成重量级锁,设置锁状态位为`10`,Mark Word 中存储指向重量级锁(互斥量)的指针.后续等待锁的线程进入阻塞状态.当前线程通过自旋尝试获取锁.

轻量级锁解锁

​	轻量级锁切换到重量级锁,是发生在轻量级锁释放锁的期间,之前在获取锁的时候,拷贝了锁对象的markword,在释放锁的时候,如果它发现,它持有锁的期间有其他线程来获取锁了,并且对Mark Word 做了修改,两者比对发现不一致,则切换到重量级锁.

​	如果线程尝试获取锁的时候,轻量级锁正被其他线程占有,那么它会修改Mark Word ,进而膨胀成重量级锁.

**重量级锁**

重量级锁是JVM 中最为基础的锁实现.在这种情况下,JVM 会阻塞加锁失败的线程,并且在目标锁被释放的时候,唤醒这些线程.

Java 线程的阻塞以及唤醒,都是依靠操作系统来完成的.(这些操作涉及操作系统调用,需要从操作系统的用户态切换至内核态,其开销非常之大)

为了避免昂贵的线程阻塞,唤醒操作,JVM 会在线程进入阻塞状态前,以及唤醒后竞争不到锁的情况下,进入**自旋状态,**在处理器上空跑并且轮训锁是否释放.如果此时锁恰好释放了,那么当前线程变无需进入阻塞状态,而是直接获得这把锁.

与线程阻塞相比,自旋状态可能会浪费大量CPU 资源.这是因为当前线程仍处于运行状况,只不过跑的是无用指令.它期望在运行无用指令的过程中,锁能够被释放出来.

JVM 的自适应自旋,根据以往自旋等待时是否能够获得锁,来动态调整自旋的时间(循环数目).

自旋的另一个副作用是不公平的锁机制.处于阻塞状态的线程,并没有办法like竞争被释放的锁.然而处于自旋状态的线程,则可能有限获得这把锁.

**重量级锁的实现**

当膨胀为重量级锁后,指向互斥量的指针指向的是monitor 对象的起始地址.每个对象都存在一个monitor 与之关联,对象与monitor 之间的关系存在多种实现方式.monitor 与对象一起创建销毁,或当线程视图获取对象锁时自动生成,当monitor 被某个线程斥候后,便处于锁定状态.

monitor 对象有两个队列 waitSet 与 entryList,这两个队列保存 ObjectWaiter 对象列表(每个等待锁的线程会被封装成ObjectWaiter对象), owner 指向持有 monitor 的线程.当线程同时访问同一段同步代码时,会先进入entryList 集合,当线程获取到对象的monitor 后,进入owner,并把monitor 中的 owner 指向当前获取锁的线程.若调用wait 方法,释放持有的monitor 对象,owner 变成null,同时进入waitSet 集合中等待唤醒.

![img](D:\idea code\selfcode\crazy_smn\doc\markdown\resource\synchronized-monitor.png)

monitor对象存在与每个java 对象的对象头中，synchronized锁便是通过这种方式获取锁的，同时这也是为什么，wait/notify/notifyAll 等方法位于顶级Object中的原因



#### 1.3.2 concurrent 包

##### 1.3.2.1 concurrent包基础

由于java 的CAS 同时具有 volatile 读 和 volatile 写的内存语义,因此java 线程之间的通信有了下面的四种方式:

1. A 线程写volatile 变量,随后B线程读取volatile 变量
2. A 线程写volatile 变量,随后B线程用CAS 更新这个volatile 变量
3. A 线程用CAS 更新volatile 变量,随后B 线程用CAS 更新这个volatile 变量
4. A 线程用CAS 更新volatile 变量,随后B 线程读取这个volatile 变量

Java 的CAS 操作 会使用现代处理器上提供的高效机器级别原子指令,这些原子指令以原子方式对内存进行 读-改-写

操作,这是在多处理器中实现同步的关键.同时,volatile 变量的读写 和 CAS 可以实现线程间通信.把这些特性整合一起就得到了concurrent 包的基石.concurrent 包通用化的实现模式:

1. 声明共享对象为volatile
2. 使用CAS 的原子条件更新,来实现线程之间的同步
3. 配合以volatile 的读写,和CAS 所具有的volatile 读和写的内存语义来实现线程之间的通信

concurrent 包的实现示意图如下:

![img](resource\concurrent-base.png)

##### 1.3.2.2 阻塞队列- BlockingQueue

BlockingQueue 通常用于生产消费场景.这是个有界队列,当队列满 存入,或队列空取出时会阻塞.

![blocking-queue](D:\idea code\selfcode\crazy_smn\doc\markdown\resource\blockingqueue-producer-consumer.png)

BlockingQueue 常用方法

|          | **抛异常** | **特定值** | **阻塞** | **超时**                    |
| -------- | ---------- | ---------- | -------- | --------------------------- |
| **插入** | add(o)     | offer(o)   | put(o)   | offer(o, timeout, timeunit) |
| **移除** | remove(o)  | poll(o)    | take(o)  | poll(timeout, timeunit)     |
| **检查** | element(o) | peek(o)    |          |                             |

BlockingQueue 的实现,java.util.concurrent 包下实现:

- ArrayBlockingQueue

  有界阻塞队列,数组实现,内部以FIFO 顺序对元素进行存储

- DelayQueue

  延迟队列,数组实现.通过PriorityQueue 保证最小时间在最前面

  元素需要实现Delayed(继承Comparable)接口,用于获取delay 延迟

- LinkedBlockingQueue

  链表阻塞队列,链表实现,无界队列,内部以FIFO 顺序对元素进行存储

- PriorityBlockingQueue

  无界并发优先队列,元素需要实现Comparable 接口,

- SynchronousQueue

  同步队列

### 1.4 JVM 相关

#### 1.4.1 JVM 启动参数

JVM 中启动参数共分为3类:

- **标准参数**             (  -  )	

  所有JVM 实现都必须实现这些参数的功能,并向后兼容

- **非标准参数**         ( -X )             

  默认jvm实现这些参数,但并不保证所有jvm 都满足,且不保证向后兼容

- **非Stable 参数**    (-XX)

  此类参数各个jvm 实现都会有所不同.可能会随时取消,需要慎重使用

**参考**

https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html

https://www.cnblogs.com/jack204/archive/2012/07/02/2572932.html

#### 1.4.2 JVM 运行时数据区规范

![img](resource\java-runtime-data-construct.png)

- **程序计数器**

  线程私有内存,用于存储线程间由于cpu 时间片执行,上下文切换后的恢复工作.不会出现`OutOfMemoryError`

- **堆**

  所有对象及数组均在堆上分配,堆是JVM 内存管理中最大的一块.

  会抛出`OutOfMemoryError: java heap space`  

  **TLAB**:每个线程在Java 堆中预先分配一小块内存,作为本地线程分配缓冲区.线程内部需要分配内存时直接在TLAB 上分配就行,避免线程间的冲突.只有当缓冲区内存用户按需要重新分配时才会进行CAS 操作分配更大的内存空间.

  相关参数:

  ​	-Xms:1024M  Java heap 初始值 (server 端程序 将 -Xms  与 -Xmx 设置相同)

  ​	-Xmx:1024M  Java heap 最大值 (server 端程序 将 -Xms  与 -Xmx 设置相同) 默认物理内存1/4

  ​	-Xmn: 384M   Java heap eden 区大小. 此值对系统性能影像较大.官方推荐 整体堆的3/8.这个值变大, 

  ​	 老年代变小

  ​	-XX:+UseTLAB 来配置(JDK 5以后默认启用TLAB)

- **Java 虚拟机栈**

  线程私有,生命周期 与 线程相同.描述java 方法执行的内存模型.用来执行方法.

  **栈帧**:java 方法执行时,会创建一个栈帧,存储**局部变量表**,**操作数栈**,**动态链接**,**方法出口**等信息.

  线程请求的栈深度大于虚拟机规定的深度,抛出`StackOverflowError` 

  在扩展栈的时候,如果无法申请到足够的内存,抛出`OutOfMemoryError`

  相关参数:

  ​	-Xss:1m	Java每个线程栈的大小.(-XX:ThreadStackSize 是某个jvm 版本的参数)

- **native 本地方法栈**

  执行虚拟机使用到的native 方法.同java 虚拟机栈一样,会抛出 `StackOverflowError` 或 `OutOfMemoryError`

- **方法区**

  又名**永久代**,用来存储JVM 中 已加载的类信息,常量,静态变量,会抛出 `OutOfMemoryError: PermGen Space` 

  运行时常量池,是方法区中的一部分,在类加载后,会把class 中的常量池放到运行时常量池中.

  **方法区的移除**: 从jdk1.7 开始,移除工作已经开始了,在jdk 1.8 中.将 类元数据 放到了本地内存中.将常量池 与 静态变量 放到java 堆里,jvm 将会为类的元数据明确分配和释放本地内存.这样就避免了原来 -XX:MaxPermSize 的限制,可以使用更多本地内存.在一定程度上解决了原有运行时生成大量类造成的`FullGC`

  **消除永久代的意义:**

  1. 字符串存放在永久代,容易出现性能问题和内存溢出
  2. 类及方法信息等难以确定大小.指定永久代大小困难.容易发生溢出 
  3. 永久代 为GC 带来复杂度.并且回收效率低
  4. Oracle 为了 HotSpot 与 JRockit 合并做准备

  相关参数:

  ​	-XX:PermSize=512m  -XX:MaxPermSize=512m 设置方法区大小 (jdk1.8 以前)

  ​	-XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m 设置元数据区大小 (jdk 1.8开始)

#### 1.4.3  Java 类加载机制

##### 1.4.3.1 **简介** 

​	查找类的字节码文件,并构造出在JVM 内部表示的对象组件.虚拟机把class 文件加载到内存,对数据进行校验,转换解析,初始化等

**类加载器:**

> BootStrap ClassLoader 启动类加载器,由C++实现,没有对应JAVA 对象(JRE lib 目录下jar,或-Xbootclasspath 指定的类)
>
> Extension ClassLoader 扩展类加载器 (JRE lib/ext 目录下的jar,或者由 java.ext.dirs 指定的类)
>
> ApplicationClassLoader 应用类加载器 (- classpath,系统变量java.class.path 或环境变量 CLASSPATH 所指定的路径)

除了BootStrap ClassLoader 加载器,其余类加载器都是 java.lang.ClassLoader 的子类,因此有对应的JAVA 	对象,这些类加载器需要先由另一个类加载器加载至JVM 中,才能执行类加载.

在JVM 中,类的唯一性是由类加载器实例,以及类的全名一同确定的,即便字节码相同,经不同类加载器加载,也会得到两个不同的类.(在大型应用中,借助这一特性,运行同一个类的不同版本)

注: 自定义类加载器,可以对class 文件进行加密,加载时,在利用自定义的类加载器对其解密.

##### 1.4.3.2 双亲委派

​	先检查是否加载过,若没有加载调用附加在其的loadClass,若父加载器为空,是用启动类加载器作为父加载器,如果父加载器加载失败.抛出ClassNotFoundException,则调用自己的findClass 方法进行加载.

为什么使用双亲委派:即防止内存中出现多份同样的字节码.安全上的考虑.

##### 1.4.3.3 类装载过程

1. 装载	

   查找,导入 class 文件,创建类的过程

2. 链接:把class 数据 合并到JVM 运行时数据区的过程

   a.校验:

   ​	检查载入class 数据的正确性

   b.准备:

   ​	给类的静态变量分配存储空间,设置默认值(非静态不在此时,静态常量值由代码决定)

   c.解析:

   ​	将符号引用转换成直接引用(JVM 将所有类,接口,字段,方法 转换为具体的内存地址),确保类之间的引用能够正确找到.  

   ​	解析过程中可能导致其他类执行加载过程.

3. 初始化

   对类的静态变量,静态代码执行初始化操作.

   一个类初始化之前,其直接父类业务被初始化.

   一个接口的初始化,不会引起其父接口的初始化,初始化的过程从上到下按顺序依次执行 静态代码 与 静态代码块

   JVM 规范枚举了如下种情况会触发初始化:

   - 虚拟机启动,初始化用户指定的主类
   - 新建目标类实例的new 指令时,初始化new 指定的目标类
   - 调用静态方法的指令时,初始化该静态方法所在的类
   - 调用静态字段的指令时,初始化该静态字段所在的类
   - 子类的初始化会触发父类的初始化
   - 一个接口定义了default 方法,直接或间接实现该接口的类的初始化,会触发该接口的初始化
   - 使用反射API对某个类进行反射调用时,初始化这个类
   - 当除此调用MethodHandle,初始化该MethodHandle 指向方法所在类(invoke dynamic)
##### 1.4.3.4 **JVM 是如何运行Java 字节码的**

​	从JVM 视角看,需要先按照上文描述的过程,将编译成的class 文件加载到jvm 中,加载后的java 类会存在方法区 中.实际运行时,虚拟机会执行方法区的方法

​	在运行时,每当调用一个Java 方法,JVM 会在当前线程的java 方法栈中生成一个栈帧,用来存放**局部变量** 以及 **字	节码操作数**,当退出执行方法时,无论执行成功失败,均会弹出当前线程栈帧.

硬件无法直接执行JAVA 字节码,JVM 需要将字节码翻译成机器代码.这个翻译过程有如下两种:

- 解释执行---无需等待编译
- 即时执行(Just-In-Time compilation ,JIT)---实际运行速度快

#### 1.4.4 JVM 的静态绑定和动态绑定

JVM 识别方法通过:**类名**,**方法名**,**方法描述符**.方法描述符由方法的**参数类型**以及**返回类型**所构成.

在同一个类中,如果同时出现**多个同名且同描述符的方法**,JVM 在类的验证阶段报错

JVM 与 JAVA  不一样,JVM 不限制 同名,同参数,但返回值不同的方法在同一类中.对于调用这些方法的字节码

字节码所附带的方法描述符包含了返回类型,所以JVM 可以准确识别目标方法.



JVM中关于重写的判定同样基于方法描述符,若子类定义了父类中非私有非静态的同名方法,只有当这两个方法的参数类型以及返回类型一致,JVM 才会认为是重写.

对于JAVA 中认为是重写,而JVM 中认定是非重写的情况,编译器会通过桥接方法来实现.

重载方法的区分在编译阶段已经完成.故可以认为在JVM 中不存在重载这一概念

在JVM 中有个不完全正确的说法:

​	重载:静态绑定,编译时多肽

​	重写:动态绑定,运行时多肽

这是因为,父类方法可能被子类方法重写,因此java 编译器将对所有非私有实例方法调用为动态绑定的类型.

#### 1.4.5 调用指定的符号引用

在编译过程中,不能确定目标方法的具体地址.因此JAVA 编译器会暂时使用符号引用来标识该目标方法.

符号引用:包括目标方法所在类或接口名字,目标方法的方法名和方法描述符

符号引用存储在class 文件的常量池中,根据目标方法是否为接口方法,引用可区分为 :**接口符号引用与非接口符号引用**

非接口符号引用:

​	假定该符号引用所指向的类C,则JVM 会按照如下步骤进行查找.

1. 在C 中查找符合名字以及描述符的方法

2. 如果没找到,在C 的父类中继续查找,直至Object类

3. 如果没找到,在C的直接实现或间接实现的接口中搜索,这一步搜索得到的目标方法必须是非私有,非静态的.并且,如果目标方法在间接实现的接口中,则需要满足C 与 该接口之间没有其他符合条件的目标方法.如果有多个符合的目标方法,任意返回其中一个.

   注:静态方法可以通过子类调用,子类的静态方法会覆盖父类的静态方法

接口符号引用:

​	假定该符号引用所指向的接口未I,则JVM 会按照如下步骤查找.

1. 在I中查找符合名字以及描述符的方法
2. 如果没找到,在Object 中的公有实例方法中搜索
3. 如果没找到,在I的超接口中搜索,过程与非接口符号引用的3一致

对于静态绑定的方法调用,实际引用是一个指向方法的指针.

对于动态绑定的方法调用,实际引用则是一个方发表的索引.

#### 1.4.6 虚方法,分派

java 字节码中调用方法的指令

| 名称            | 备注                                                         |
| --------------- | ------------------------------------------------------------ |
| invokestatic    | 调用静态方法                                                 |
| invokespecial   | 调用私有实例方法,new 关键字,super 关键字,所实现接口的默认方法 |
| invokeinterface | 调用接口方法                                                 |
| invokevirtual   | 调用非私有实例方法                                           |
| invokedynamic   | 调用动态方法(MethodHandle)                                   |

对于 invokestatic 与 invokespecial 来说JVM 能够直接识别目标方法

对于invokevirtual与 invokeinterface 来说JVM 需要在执行过程中根据调用者动态类型来执行具体目标方法.

在java 中,除了使用`final` `static` `private`  为非虚方法,其余均为虚方法

- 虚方法--动态绑定:

  虚方法调用通过invokevirtual,分两次分派,第一步在编译期看方法调用者和参数的静态类型,第二部在运行期只看方法调用者的动态类型.

- 非虚方法--静态绑定:

  对于非虚方法的调用,程序在编译阶段,就可以唯一确定一个可以调用的版本.并且这个方法在运行期不可改变,会在类加载的解析阶段,通过`invokestatic` `invokespecial` 指令将对非虚方法的符号引用转换为直接引用.

  非虚方法调用只看对象的静态类型(引用类型).

JVM 会采用空间换时间的策略来实现动态绑定,为每个类生成一个方发表,用以快速定位目标方法.

#### 1.4.7 方发表

在类加载的准备阶段,除了为静态字段分配内存,还会构造与该类关联的方发表

这个数据结构,是JVM 实现动态绑定的关键所在.下文中将用invokevirtual 锁使用的虚方法表(virtual method table vtable)为例介绍方发表用法,invokeinterface 所适用的接口方法表稍微复杂,原理类似.

方发表本质上是一个数组,每个数组元素指向一个当前类及其父类中非私有的实例方法.

这些方法可能是具体的可执行方法,也可能是没有相应字节码的抽象方法.方法表满足两个特质:

1. 子类方法表中包含父类方法表所有方法
2. 子类方法在方法表中的索引值,与它所重写的父类方法的索引值相同

上文中曾经说过,方法调用指令中的符号引用会在执行前解析成实际引用.对于静态绑定的方法调用,实际引用指向目标具体方法.对于动态绑定的方法调用,实际引用指向方法表的索引值(实际上 并不仅是索引值)

**动态绑定:**在实际实行过程中,JVM 将会获取调用者的实际类型,并在该实际类型的虚方法表中,根据索引值获得目标方法.

注: 实际上,使用了方法表的动态绑定与静态绑定相比,仅仅多出几个内存解引用操作:访问栈上的调用者,读取调用者的动态类型,读取该类型的方法表,读取方法表中某个索引值所对应的目标方法.但是,不能认同虚方法调用对性能没有太大影响,上述优化过程中仅存在与解释执行过程中,或即时编译最坏情况.即时编译还有另外两种性能更好的优化手段:内联缓存(inlining cache),方法内联(method inlining)

#### 1.4.8 内联缓存

内联缓存是一种加快动态绑定的优化技术,它能够缓存虚方法调用中调用者的动态类型,以及该类型所对应的目标方法.在之后的执行过程中,若碰到已缓存的类型,内联缓存变会直接调用该类型所对应的目标方法.若没有碰到已缓存的类型,内联缓存会退化至**基于方法表的动态绑定**

针对多态的优化手段中,通常涉及如下三个术语:

1. 单态	仅有一种状态
2. 多态    有限数量种状态的情况
3. 超多态 更多的状态情况,通常会有一个具体数值来区分多肽和超多态,数值下成为多态,反之

对于内联缓存来说分别对应了,单态,多态,超多态内联缓存.在实践中,大部分的虚方法调用时单态的,也就是只有一种动态类型,为了节省内存空间,JVM 只采用单态内联缓存.

当内联缓存没有命中的情况下,JVM 需要重新使用方法表进行动态绑定.对于内联缓存汇总的内容,有两种选择.

1. 替换单态内联缓存中的记录,但是在最坏情况下,我们使用两种不同的调用者,轮流执行该方法调用,那么每次进行方法调用都将替换内联缓存.只有写缓存的开销,但是缓存却没有利用上.
2. JVM 劣化为超多态,处于这种状态下的内联缓存,放弃了优化机会,将直接访问方法表,来动态绑定目标方法



注意:虽然内联缓存 有内联二字,但是它并没有内联目标方法.这里需要明确的是,任何方法调用除非被内联,否则都会有固定开销.这些开销来源于保存程序在该方法中执行位置,以及新建,压入和弹出新方法所使用的栈帧. 对于及其简单的方法而言,如getter/setter 这部分固定开销占据的CPU 时间甚至超过了方法本身.在即时编译中,方法内联不仅仅能够消除方法调用的固定开销,而且还增加了进一步优化的可能性.

#### 1.4.9 应用重启抖动

​	Java 程序在启动的时候,所有代码的执行处于解释执行模式,在运行一段时间后,根据代码执行次数,才会编译成机器代码.

​	**解决方式:**

​		1.程序主动预热: 启动完成后,主动访问热点代码.确保主要热点代码已经被编译成机器码后在放入流量.可以通

​			过`-XX:+PrintCompilation` 确认

​		2.复制流量预热,通过`tcpcopy`软件,拷贝一份线上nginx 流量进行预热,完成后在导入线上流量

​		3.启用多线程进行编译优化

#### 1.4.10 JVM处理反射

反射是JAVA 中的重要特性,它允许正在运行的JAVA 程序观测,甚至是修改程序行为.

举例来说,我们可以通过Class 对象枚举该类中的所有方法,还可以通过Method.setAccessible 绕过Java 语言的访问权限,访问私有方法.

在Web 开发中,经常接触到各种配置通用框架,为了保证框架的可扩展性,一般借助JAVA 反射机制,来根据不同配置加载不同的类.Spring 的依赖反转(IOC)便是依赖反射机制

**反射调用的实现**

```java
public final class Method extends Executable {
	...
    @CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException{
        ...
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    } 
    ...
}
```

从上述源码可得,Method 的invoke 方法实际上委派给MethodAccessor 来处理.MethodAccessor 是一个接口,有两个具体实现

1. 通过本地方法来实现反射调用.		<本地实现>		调用native 本地方法
2. 使用了委派模式                                <委派实现>        

Method 实例的第一次反射调用都会生成一个委派实现,委派具体实现是一个本地实现.本地实现可以理解成--当进入了JVM内部后,便拥有了Method 实例所指向方法的具体地址.这时候,反射调用就是将传入的参数准备好,然后调用进入目标方法.

例V0版本ReflectTest:

```java
public class ReflectTest {
    public static void target(int i){
        new Exception("#"+i).printStackTrace();
    }
    public static void main(String[] args) throws ClassNotFoundException, 	
    		NoSuchMethodException, 
    		InvocationTargetException, 
    		IllegalAccessException {
        Class klass = Class.forName("jvmtest.ReflectTest");
        Method method = klass.getMethod("target",int.class);
        method.invoke(null,0);

    }
}
```



执行上述代码后,会抛出调用的堆栈信息如下:

```java
java.lang.Exception: #0
	at jvmtest.ReflectTest.target(ReflectTest.java:14)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at jvmtest.ReflectTest.main(ReflectTest.java:19)
```

从上述堆栈信息中可以看出,反射调用过程如下:

1. 执行Method.invoke
2. 执行DelegationMethodAccessorImpl.invoke-- 委派实现
3. 执行NativeMethodAccessorImpl.invoke--本地实现

为什么反射调用还要采取委派实现作为中间层?

Java 的反射调用机制还设立了另一种动态字节码的实现,直接使用invoke指令来调用目标方法,之所以采取委派实现,便是为了能够在本地实现以及动态字节码实现中切换.

动态实现与本地实现相比,其运行效率要快上20倍左右.这是因为动态实现无需经过JAVA 到C++ 再到JAVA 的切换,但由于生成字节码十分耗时,仅调用一次的话,反而是本地实现要快上3到4倍.

考虑到许多反射调用仅调用一次,JAVA 虚拟机设置了一个阈值15(可以通过 **-Dsun.reflect.inflationThreshold=value** 调整),当某个反射的调用次数在15之下时,采用本地实现,当达到15时,便开始动态生成字节码,并将委派实现对象切换至动态实现,这个过程称为Inflation(扩充).



例V1版本ReflectTest:

```java
public class ReflectTest {
    public static void target(int i){
        new Exception("#"+i).printStackTrace();
    }
    public static void main(String[] args) throws ClassNotFoundException, 
    		NoSuchMethodException, 
    		InvocationTargetException, 
    		IllegalAccessException {
        Class klass = Class.forName("jvmtest.ReflectTest");
        Method method = klass.getMethod("target",int.class);
        for(int i=0;i<20;i++) {
            method.invoke(null, i);
        }

    }
}
```

第15,16次执行堆栈信息如下:

```
java.lang.Exception: #15
	at jvmtest.ReflectTest.target(ReflectTest.java:14)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at jvmtest.ReflectTest.main(ReflectTest.java:20)
java.lang.Exception: #16
	at jvmtest.ReflectTest.target(ReflectTest.java:14)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at jvmtest.ReflectTest.main(ReflectTest.java:20)
```

可以看到,在第十五次反射调用,触发了动态实现的生成,这是JVM 加载了不少类,如GeneratedMethodAccessor1,并且从第16次反射调用开始,便切换至这个刚刚生成的动态实现.

反射调用的Inflation机制是可以通过参数(**-DSun.reflect.noInflation=true**)来关闭的,这样在反射调用一开始便会直接生成动态实现,而不会使用委派实现或者本地实现.

**反射调用的开销**

在前面写的例子中,我们先后进行了 Class.forName,Class.getMethod,Method.invoke 三个操作.其中Class.forName 会调用本地方法,Class.getMethod 则会遍历该类的公有方法,若未查询到会遍历父类的公有方法.这两个操作都异常耗时.

注意:getMethod 为代表的的查找方法,会返回当前查找得到结果的一份拷贝.因此避免在热点代码中使用返回Method 数组的getMethods或getDeclaredMethods,以减少不必要的对空间消耗.获取同一个方法的两个Method 对象,equals 相同.

在实践中,我们往往会在应用程序中缓存Class.forName 和 Class.getMethod 的结果.因此我们只关注反射调用本身的性能开销.

#### 1.4.11 压缩指针

**对象头(object header)**

在JVM 中每个对象都有一个**对象头**(**object header**),由**标记字段**和**类型指针**构成

标记字段:

> 存储JVM有关该对象的运行数据:哈希码,GC 信息,锁信息,

类型指针:

> 类型指针指向该对象的类

在64位JVM 中,对象头的标记字段占64位,而类型指针又64位,说明,每个Java 对象在内存中额外开销就是16个字节.以Integer 为例,它仅有一个int 类型的私有字段,占4个字节.因此每一个Integer 对象的额外内存开销是400%.(这也是Java 引入基本数据类型的原因之一)

为了尽量减少对象的内存使用量,64位的JVM引入了压缩指针的概念(-**XX:+UseCompressedOops**,默认开启),将堆中原本64位的Java 对象压缩成32位.这样对象头中的类型指针也被压缩成32位,使得对象头的大小由16个字节降至12个字节.压缩指针不仅可以作用于对象头的类型指针,还可以作用于引用类型的字段,以及类型数组

**压缩指针的原理**

JVM 有32位与 64位:

1. 32位对应4G 内存寻址空间
2. 64位对应 32G内存寻址空间(正常来讲是8G,开启压缩指针达到了 32G)

64位JVM 在支持更大寻址空间的同时,对象引用占用了8个字节,带来了如下问题:

1. 增加了GC 开销,对象引用挤占了对象数据存储,更易触发GC
2. 64位对象引用增大了,CPU 能缓存的对象指针(OOP)将会更少,降低了CPU 缓存的效率

为了保持,32位的性能,对象指针必须保留32位,如何使用32位OOP来引用更大的堆内存呢->通过压缩指针

JVM 的实现方式是,不在保存所有引用,而是每隔8个字节保存一个引用(通过移位实现),堆中的引用实际存储时还是按照0x0,0x1,0x2 ...进行存储.只不过当引用被存入64位寄存器的时候,JVM 会将其左移3位,转换成 0x0,0x8,0x10.而当从寄存器读出时,JVM 右移3位.

因此计算:

​	32位JVM: 2^32=4G 寻址空间,

​	64位JVM:2^32 * 3(通过偏移)=32G 寻址空间

上述的模型,移位同时需要有个前提,对象的起始地址需要对齐至8的倍数,如果一个对象用不到8N个字节,那么空间就浪费了.浪费的空间成为对象间的填充padding.(对应 -XX:ObjectAlignmentInBytes,默认为8),把这个概念成为**内存对齐**



注:就算关闭了压缩指针,JVM 还是会进行**内存对齐**,此外,内存对齐不仅存在于对象与对象之间,也存在于对象中的字段之间,字段**内存对齐**的其中一个原因,是让字段只出现在同一CPU 缓存行.为了防止出现**CPU伪共享缓存行**问题

#### 1.4.12 CPU Cache 伪共享

缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。

![img](resource\cpu-cache.png)

> Java8 引入了一个新的注释@Contended ,用来解决CPU 伪共享问题:
>
> 两个线程访问同一对象中不同的volatile 字段,逻辑上,它们没有共享内容不需要同步,然后若这两个字段恰好在同一CPU缓存行中,那么对这些字段的写操作会导致缓存行的写回

### 1.5 垃圾回收

#### 1.5.1 判断对象是否存活

- **引用计数法**

  对象中添加引用计数器,有引用+1,引用失效-1.效率高,但难以处理对象互相引用的问题.

- **可达性分析**

  通过一些列`GC Roots` 的对象作为起点,向下搜索,搜索的路径为引用链,当一个对象到`GC Roots` 没有任何引用链相连接的时候,证明此对象是不可用的.

  可作为`GC Roots` 的对象:

  - 虚拟机栈中引用的对象
  - 方法区静态属性引用的对象
  - 方法区常量引用的对象
  - 本地方法栈中JNI 引用的对象

  在可达性分析中,不可达的对象也不一定是要死的.最少要被两次标记成不可达,第一次发现没有与`GC Roots`的引用链后,会被进行第一次标记,并进行第一次 筛选,筛选条件是是否有必要实行finalize 方法.

  **引用划分**:强引用,软引用,弱引用,虚引用 

#### 1.5.2 垃圾回收算法

##### 1.5.2.1 标记清除(Mark-Sweep)

分为**标记阶段**,**清除阶段**

![img](resource\garbage-collect-mark-sweep.png)

**缺点:** 

​	效率问题,标记与清除过程效率都不高

​	空间问题,会产生大量不连续的内存碎片,空间碎片太多可能导致在分配大对象时,找不到连续内存,提前触发GC

##### 1.5.2.2 复制(copying) 

解决标记清除效率问题.将内存按照容量划分成大小相等的两块,每次使用一块,对另一块进行内存回收,清除一整块空间,简单高效. **新生代一般采用此算法** eden 区会按照 8:1:1 划分成 eden 区,from survivor 区,to survivor 区,只用10% 来进行垃圾回收.

survivor 若空间没有足够内存存放存活对象时,会直接放进老年代.在eden 区中经过 N 次GC 的对象会迁移至老年代中. N 可配置.

![1577785888590](D:\idea code\selfcode\crazy_smn\doc\markdown\resource\garbage-collect-copying.png)

**缺点:**



##### 1.5.2.3 标记整理-压缩

分为**标记阶段**,**整理阶段**(让存活对象向其中一端移动,然后清除边界外的内存).一般用在老年代.

![1577786475220](resource\garbage-collect-mark.png)

##### 1.5.2.4 分代收集

**新生代:**  采用复制算法,一般一次可以回收 70%~95% 的空间

**老年代: ** 采用标记整理,或标记清除

#### 1.5.3 垃圾回收器

垃圾回收器类型:

- 串行回收,Serial 回收器,单线程回收,STW
- 并行回收,Parallel * 回收器,多线程回收.STW
- 并发回收,CMS 与 G1 ,多线程分阶段回收,只有某些特定阶段会 STW.

##### 1.5.3.1 Serial/Serial Old

​	Serial 复制算法					单线程	新生代	STW

​	Serial Old 标记整理算法	 单线程	老年代	STW

​	**相关参数:**

​			-XX:+UseSerialGC

##### 1.5.3.2 Throughput(默认)

​	**ParNew**

​	**Parallel Scavenge** 复制算法	多线程	新生代	STW

​	**Parallel Old** 标记整理算法		多线程	老年代	STW

​	**相关参数:**

​		-XX:+UseParallelGC  虚拟机运行在server 模式下的默认值,使用Parallel Scavenge+ Serail Old 组合

​		-XX:+UseParNewGC  启用ParNew + Serail Old 组合

​		-XX:+UseParallelOldGC 使用Parallel Scavenge + Parallel Old 的收集器组合

##### 1.5.3.3 CMS(Concurrent Mark Sweep)

​	CMS只会回收**老年代** 与 **方法区**(元数据区),不会收集**年轻代**

​	CMS是一种预处理垃圾回收器,它不能等到old 内存用尽时回收,需要在内存用尽前,完成回收工作,否则导致并发回	收失败;所以cms 垃圾回收器开始执行回收操作,有一个触发阈值,默认 老年代或 方法区 为 92%.

​	**使用场景:** 适合对延时要求较高的引用.用户线程下不允许长时间的停顿.

​	**缺点:**

​		服务长时间运行,造成严重的内存碎片化. 

​		对CPU 资源敏感,并发阶段虽然不会暂停用户线程,但会影像执行效率

​		无法处理浮动垃圾.

​		算法实现比较复杂.

​	**相关参数:**

​		-XX:+UseConcMarkSweepGC 开启CMS GC

​		-XX:+CMSClassUnloadingEnabled 开启元数据区垃圾回收

​		-XX:ParallelCMSThreads=	并发标记扫描垃圾回收器使用的线程数量

##### 1.5.3.4 G1(Garbage First)

​	`G1 GC`使用 并发 和 并行阶段实现其目标暂停时间,并保持良好的吞吐量,当`G1 GC`确定有必要执行垃圾回收时,会	先收集存活数据最少的区域.	

​	Garbage First 是一个横跨新生代和老年代的垃圾回收器,实际上,它已经打乱了前面所说的堆结构,直接将堆分成	及其多个区域,每个区域都可以充当Eden区,Survivor 区,或者老年代.采用的是标记压缩算法.

​	**相关参数:**

​		-XX:+UseG1GC

##### 1.5.3.5 内存分配 与 回收策略

- 对象优先在 新生代 Eden 分配,空间不足会触发 `Minor GC`,`Minor GC` 后空间 不足,通过**担保机制**进入老年代.

- 大对象直接进入老年代,避免短命大对象.可以使用 -XX:PretenureSizeThreshold 设置.仅在Serial 与ParNew 收集器有效.

- 长期存活的对象进入老年代,经过一次Minor GC 新生代的对象就会涨一岁.可以通过

  -XX:MaxTenuringThreshold

- **动态对象年龄判定**.针对小于MaxTenuringThreshold 的对象,如果survivor 中,年龄相同所有对象的大小总和大于Survivor 空间的一半,大于等于该年龄的对象可以直接进入老年代.

- **空间分配担保** 在`Minor GC` 前会检查,若老年代最大可用连续空间大于新生代总空间,`Minor GC` 是安全的.否则 根据`HandlePromotionFailer`  是否允许担保失败,可以的话会检查历史上最大可用连续空间是否大于晋升老年代对象的平均大小,如果大于,尝试进行一次有风险的`Minor GC`,小于或者不担保执行`FullGC`

##### 1.5.3.6 垃圾收集器参数

| 参数名                         | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | Client 模式下的默认值，使用Serial+SerialOld 的收集器组合进行回收 |
| UseParNewGC                    | ParNew + Serial Old 的收集器组合进行内存回收                 |
| UseConcMarkSweepGC             | ParNew + CMS + Serial Old 的收集器组合进行回收。Serial Old 作为 CMS 出现 Concurrent Mode Failure 失败后使用 |
| UseParallelGC                  | server 模式下的默认值，打开开关后，使用Parallel Scavenge +Serial Old 收集器组合进行回收 |
| UseParallelOldGC               | Parallel Scavenge + Parallel Old 的收集器组合进行内存回收。  |
| SurvivorRatio                  | 新生代Eden 与 survivor 区域的容量比例 默认 8:1               |
| PretenureSizeThreshold         | 直接晋升老年代的对象大小设置                                 |
| MaxTenuringThreshold           | 新生代晋升老年代年龄 值，当新生代年龄等于该值，晋升老年代    |
| UseAdaptiveSizePolicy          | 动态调整java 堆中 各个区域的大小，以及进入老年代的年龄       |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不够新生代的 Eden 与 Survivor 区的所有对象都存活的极端情况。 |
| ParallelGCThreads              | 设置并行GC 时进行内存回收的线程数                            |
| GCTimeRatio                    | GC时间占总时间的比率，默认 99 ，即仅允许1% 的GC 时间，只针对 Parallel Scavenge 收集器时生效 |
| MaxGCPauseMillis               | 设置GC 的最大停顿时间。尽在使用Parallel Scavenge 收集器时生效 |
| CMSInitiatingOccupancyFraction | 设置CMS 收集器在老年代空间在使用多少后出发垃圾回收，默认值68 |
| UseCMSCompactAtFullCollection  | 设置CMS 收集器在完成垃圾回收后是否进行一次内存碎片整理。     |
| CMSFullGCsBeforeCompaction     | 设置CMS 收集器在进行若干次 垃圾回收后，启动一次内存碎片整理。 |



## 常用框架

### Spring Framework

### SpringMVC

### Mybatis

### Guava

### SpringBoot

## Spring Cloud

### Eureka

### Ribbon

### Hystrix

### Feign

### Netflix Zull

### Spring Bus

### Spring Cloud Config

## 中间件

### zookeeper

### redis

### mysql

### rabbitmq

### keepalived

### openresty

### haproxy

### etcd

## 分布式

CAP

BASE

分布式锁

雪崩

高并发

CDN

