# 路径

## 1 JAVA 相关

### 1.1 JAVA 基础

#### 1.1.1 Java 类加载机制

##### 1.1.1.1 简介 

​	查找类的字节码文件,并构造出在JVM 内部表示的对象组件.虚拟机把class 文件加载到内存,对数据进行校验,转换解析,初始化等

##### 1.1.1.2 双亲委派:

​	先检查是否加载过,若没有加载调用附加在其的loadClass,若父加载器为空,是用启动类加载器作为父加载器,如果父加载器加载失败.抛出ClassNotFoundException,则调用自己的findClass 方法进行加载.

##### 1.1.1.3 类装载过程:

1. 装载	

   查找,导入 class 文件

2. 链接:把class 数据 合并到JVM 运行时数据区的过程

   a.校验:

   ​	检查载入class 数据的正确性

   b.准备:

   ​	给类的静态变量分配存储空间,设置默认值(非静态不在此时,静态常量值由代码决定)

   c.解析:

   ​	将符号引用转换成直接引用(JVM 将所有类,接口,字段,方法 转换为具体的内存地址),确保类之间的引用能够正确找到.  

   ​	解析过程中可能导致其他类执行加载过程.

3. 初始化

   对类的静态变量,静态代码执行初始化操作.

   一个类初始化之前,其直接父类业务被初始化.

   一个接口的初始化,不会引起其父接口的初始化,初始化的过程从上到下按顺序依次执行 静态代码 与 静态代码块

   Java 类  与 接口 触发初始化的过程:

   - 创建Java 实例
   - 调用静态方法
   - 给静态变量赋值
   - 访问静态变量
   - 在顶层java 类中执行assert 语句

#### 1.1.2 虚方法,分派

在java 中,除了使用`final` `static` `private`  为非虚方法,其余均为虚方法

- 虚方法--动态绑定:

  虚方法调用通过invokevirtual,分两次分派,第一步在编译期看方法调用者和参数的静态类型,第二部在运行期只看方法调用者的动态类型.

- 非虚方法--静态绑定:

  对于非虚方法的调用,程序在编译阶段,就可以唯一确定一个可以调用的版本.并且这个方法在运行期不可改变,会在类加载的解析阶段,通过`invokestatic` `invokespecial` 指令将对非虚方法的符号引用转换为直接引用.

  非虚方法调用只看对象的静态类型(引用类型).



### 1.2 Guava 基础

### 1.3 并发框架

### 1.4 JVM 相关

#### 1.4.1 JVM 启动参数

JVM 中启动参数共分为3类:

- **标准参数**             (  -  )	

  所有JVM 实现都必须实现这些参数的功能,并向后兼容

- **非标准参数**         ( -X )             

  默认jvm实现这些参数,但并不保证所有jvm 都满足,且不保证向后兼容

- **非Stable 参数**    (-XX)

  此类参数各个jvm 实现都会有所不同.可能会随时取消,需要慎重使用

**参考**

https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html

https://www.cnblogs.com/jack204/archive/2012/07/02/2572932.html

#### 1.4.1 JVM 运行时数据区规范

![img](resource\java-runtime-data-construct.png)

- **程序计数器**

  线程私有内存,用于存储线程间由于cpu 时间片执行,上下文切换后的恢复工作.不会出现`OutOfMemoryError`

- **堆**

  所有对象及数组均在堆上分配,堆是JVM 内存管理中最大的一块.

  会抛出`OutOfMemoryError: java heap space`  

  相关参数:

  ​	-Xms:1024M  Java heap 初始值 (server 端程序 将 -Xms  与 -Xmx 设置相同)

  ​	-Xmx:1024M  Java heap 最大值 (server 端程序 将 -Xms  与 -Xmx 设置相同) 默认物理内存1/4

  ​	-Xmn: 384M   Java heap eden 区大小. 此值对系统性能影像较大.官方推荐 整体堆的3/8.这个值变大, 

  ​	 老年代变小

- **Java 虚拟机栈**

  线程私有,生命周期 与 线程相同.描述java 方法执行的内存模型.用来执行方法.

  **栈帧**:java 方法执行时,会创建一个栈帧,存储**局部变量表**,**操作数栈**,**动态链接**,**方法出口**等信息.

  线程请求的栈深度大于虚拟机规定的深度,抛出`StackOverflowError` 

  在扩展栈的时候,如果无法申请到足够的内存,抛出`OutOfMemoryError`

  相关参数:

  ​	-Xss:1m	Java每个线程栈的大小.(-XX:ThreadStackSize 是某个jvm 版本的参数)

  ​	

- **native 本地方法栈**

  执行虚拟机使用到的native 方法.同java 虚拟机栈一样,会抛出 `StackOverflowError` 或 `OutOfMemoryError`

- **方法区**

  又名**永久代**,用来存储JVM 中 已加载的类信息,常量,静态变量,会抛出 `OutOfMemoryError: PermGen Space` 

  运行时常量池,是方法区中的一部分,在类加载后,会把class 中的常量池放到运行时常量池中.

  **方法区的移除**: 从jdk1.7 开始,移除工作已经开始了,在jdk 1.8 中.将 类元数据 放到了本地内存中.将常量池 与 静态变量 放到java 堆里,jvm 将会为类的元数据明确分配和释放本地内存.这样就避免了原来 -XX:MaxPermSize 的限制,可以使用更多本地内存.在一定程度上解决了原有运行时生成大量类造成的`FullGC`

  **消除永久代的意义:**

  1. 字符串存放在永久代,容易出现性能问题和内存溢出
  2. 类及方法信息等难以确定大小.指定永久代大小困难.容易发生溢出 
  3. 永久代 为GC 带来复杂度.并且回收效率低
  4. Oracle 为了 HotSpot 与 JRockit 合并做准备

  相关参数:

  ​	-XX:PermSize=512m  -XX:MaxPermSize=512m 设置方法区大小 (jdk1.8 以前)

  ​	-XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m 设置元数据区大小 (jdk 1.8开始)

### 1.5 垃圾回收

#### 1.5.1 判断对象是否存活

- **引用计数法**

  对象中添加引用计数器,有引用+1,引用失效-1.效率高,但难以处理对象互相引用的问题.

- **可达性分析**

  通过一些列`GC Roots` 的对象作为起点,向下搜索,搜索的路径为引用链,当一个对象到`GC Roots` 没有任何引用链相连接的时候,证明此对象是不可用的.

  可作为`GC Roots` 的对象:

  - 虚拟机栈中引用的对象
  - 方法区静态属性引用的对象
  - 方法区常量引用的对象
  - 本地方法栈中JNI 引用的对象

  在可达性分析中,不可达的对象也不一定是要死的.最少要被两次标记成不可达,第一次发现没有与`GC Roots`的引用链后,会被进行第一次标记,并进行第一次 筛选,筛选条件是是否有必要实行finalize 方法.

  **引用划分**:强引用,软引用,弱引用,虚引用 

#### 1.5.2 垃圾回收算法

##### 1.5.2.1 标记清除(Mark-Sweep)

分为**标记阶段**,**清除阶段**

![img](resource\garbage-collect-mark-sweep.png)

**缺点:** 

​	效率问题,标记与清除过程效率都不高

​	空间问题,会产生大量不连续的内存碎片,空间碎片太多可能导致在分配大对象时,找不到连续内存,提前触发GC

##### 1.5.2.2 复制(copying) 

解决标记清除效率问题.将内存按照容量划分成大小相等的两块,每次使用一块,对另一块进行内存回收,清除一整块空间,简单高效. **新生代一般采用此算法** eden 区会按照 8:1:1 划分成 eden 区,from survivor 区,to survivor 区,只用10% 来进行垃圾回收.

survivor 若空间没有足够内存存放存活对象时,会直接放进老年代.在eden 区中经过 N 次GC 的对象会迁移至老年代中. N 可配置.

![1577785888590](D:\idea code\selfcode\crazy_smn\doc\markdown\resource\garbage-collect-copying.png)

**缺点:**



##### 1.5.2.3 标记整理

分为**标记阶段**,**整理阶段**(让存活对象向其中一端移动,然后清除边界外的内存).一般用在老年代.

![1577786475220](resource\garbage-collect-mark.png)

##### 1.5.2.4 分代收集

**新生代:**  采用复制算法,一般一次可以回收 70%~95% 的空间

**老年代: ** 采用标记整理,或标记清除

#### 1.5.3 垃圾回收器

##### 1.5.3.1 Serial/Serial Old

Serial 复制算法					单线程	新生代	STW

Serial Old 标记整理算法	 单线程	老年代	STW

##### 1.5.3.2 Throughput(默认)

​	**Parallel Scavenge** 复制算法	多线程	新生代	STW

​	**Parallel Old** 标记整理算法		多线程	老年代	STW

##### 1.5.3.3 CMS

##### 1.5.3.4 G1(Garbage First)

### 1.6 内存模型

## 常用框架

### Spring Framework

### SpringMVC

### Mybatis

### Guava

### SpringBoot

## Spring Cloud

### Eureka

### Ribbon

### Hystrix

### Feign

### Netflix Zull

### Spring Bus

### Spring Cloud Config

## 中间件

### zookeeper

### redis

### mysql

### rabbitmq

### keepalived

### openresty

### haproxy

### etcd

## 分布式

CAP

BASE

分布式锁

雪崩

高并发

CDN

