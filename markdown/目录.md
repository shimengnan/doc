[TOC]



## 1 JAVA 相关

### 1.1 JAVA 基础

#### 1.1.1 内存模型 (JMM)

工作内存对应着 JVM 运行时数据区的 JVM 栈,而主内存对应着 堆(线程不安全) 与 方法区(线程安全)

##### 1.1.1.1 主内存 与 工作内存

**Java 角度看内存**

![img](resource\jmm-memory.png)

**硬件角度看内存**

![img](resource\hardware-memory.png)

- 寄存器

  每个CPU 中都有一系列的 寄存器,CPU 在寄存器上计算操作要比内存中快的多.

- 高速缓存

  每个CPU 都会有一个CPU 的Cache 内存,CPU 访问Cache 的速度要快于访问内存的速度,慢于访问寄存器的速度.一般会分为多级,一级 cpu 独享,二级 或 三级 CPU 分组共享 或 全部共享

- 主存 多个CPU 共享.访问速度慢.

CPU Cache 伪共享问题

##### 1.1.1.2 内存间的原子性操作

|        |      |          |                                                   |
| ------ | ---- | -------- | ------------------------------------------------- |
| lock   | 锁定 | 主内存   | 变量处于线程独占状态                              |
| unlock | 解锁 | 主内存   | 变量从锁定状态释放                                |
| read   | 读取 | 主内存   | 将主内存变量传递到工作内存,便于后续load           |
| load   | 载入 | 工作内存 | 将从主内存read 操作的变量放入到工作内存           |
| use    | 使用 | 工作内存 | 将工作内存中的变量传递给执行引擎                  |
| assign | 赋值 | 工作内存 | 将执行引擎中的值付给工作内存中的变量              |
| store  | 存储 | 工作内存 | 将工作内存中的变量传送到主内存,便于后续write 操作 |
| write  | 写入 | 工作内存 | 将工作内存store操作的变量存入到主内存中           |

##### 1.1.1.3 内存间的交互规则

1. 从主存读,要顺序执行 read,load 操作
2. 向主存写,要顺序执行 store,write 操作
3. 1,2 中的要求的顺序,非连续  如:read a, read b,load a,load b
4. read,load 或 store,write 必须成对出现,不能单独出现.
5. 不允许线程丢弃它的最近assign 操作
6. 不允许线程把没有发生过assign 操作的数据同步到主内存
7. 新变量只能在主存中产生,不允许在工作内存中使用未经初始化的变量
8. 一个变量同一时刻只允许一条线程进行lock 操作,但lock,unlock 可以被同一个线程执行多次.
9. 对一个变量进行lock操作,会清空工作内存中此变量的值,后面需要重新load  或 assign 操作初始化变量的值
10. 线程不能unlock 未被lock 锁定的变量,也不能unlock 被其他线程锁定的变量
11. 执行unlock 前,必须把变量同步回到主存中 执行store write 操作.

##### 1.1.1.4 volatile 变量的特殊规则

volatile 特性是无法分配到寄存器中,**新值立即同步到主存中,每次使用前从主存中刷新.**

Java 中的运算并非原子操作.volatile 变量并发下并不一定安全

**volatile 修饰后,禁止指令重排优化**.普通变量仅仅保证在方法执行过程中,所依赖赋值结果的地方都能正确获取到结果.不能保证变量操作的顺序与代码中执行顺序一致.

##### 1.1.1.5 原子性 可见性 有序性

**原子性**:基本数据类型访问读写 是原子的.read load write store use assign .更大范围的原子性需要借助java 的 lock 与 unlock 来实现.

**可见性**:volatile 可见性,synchronized 可见性(参考 1.1.1.3 中规则11 ),final 可见性(值无法改变)

**有序性**:同一线程内 所有的操作都是有序的,在其他线程观察,操作是无需的,可以使用volatile 与 synchronized 来保证线程间的有序性.

##### 1.1.1.6 happens-before

1. 程序次序规则:同一线程内按照程序代码顺序执行
2. 管程锁定规则:一个unlock操作,先行发生于后面的lock
3. volatile 变量规则:对一个volatile变量的写操作先行发生于后面变量的读操作
4. 线程启动规则:start 方法,发生于线程的第一个动作
5. 线程终止规则:线程的所有操作都先于线程的终止动作
6. 线程中断规则:对线程interrupt 方法的调用,先于 被中断线程检测到中断的发生
7. 对象终结规则:对象的初始化操作 先行与 finalize 操作
8. 传递性:如果A 先行与 B,B先行于C 那么A 先行于C

#### 1.1.2 Java 基本类型说明

JAVA 基本数据类型有八种:boolean,byte,short,int,long,double,float,char

> 在JAVA中,boolean 的值只有两种可能 true/false.JVM显然不能直接使用 true/false 标识boolean 类型
>
> 在JVM 中,boolean 的类型被映射成了int 类型, true 用 1表示,false 用0表示.

Java 基本类型说明

| 类型    | 值域                | 默认值   | 虚拟机内部符号 |
| ------- | ------------------- | -------- | -------------- |
| boolean | {false,true}        | false    | Z              |
| byte    | [-128,127]          | 0        | B              |
| short   | [-32768,32767]      | 0        | S              |
| char    | [0,65535]           | '\u0000' | C              |
| int     | [-2^31,2^31 -1]     | 0        | I              |
| long    | [-2^63,2^63 -1]     | 0L       | L              |
| float   | ~[-3.4E38,3.4E38]   | +0.0F    | F              |
| double  | ~[-1.8E308,1.8E308] | +0.0D    | D              |

**基本类型在栈上占用空间的大小:**

栈帧有两个主要组成部分,**局部变量区,字节码的操作数栈.**这里的局部变量是广义的,除了普通的局部变量,还包含实例方法的**"this指针"**以及方法所接收参数.

在JVM 规范中,局部变量区等价于一个数组,并且可以用正整数来索引.除了long double 值用两个数组单元存储,其他基本类型以及引用类型的值均占用一个数组单元.

说明,boolean ,byte short char 这四种类型,在栈上用的空间和int 是一样的,和引用类型也是一样的.因此,在32位HotSpot 这些类型占用**4个字节**,在64位HotSpot 占用**8个字节**.

注意,这种情况仅存在与局部变量中,而并不会出现在存储于对堆中的字段或者数组元素上.对于byte,char,short 这三种类型的字段或者数组单元,它们在堆上占用的空间分别为一字节,两字节,两字节,与类型匹配.

Java 基本类型的加载

JVM 的算术运算几乎全部依赖于操作数栈.也就是说,我们需要将堆中的 boolean,byte,char 以及 short 加载到操作数栈上,而后将栈上的值当做int 进行运算.

对于 boolean 与 char 这两个**无符号类型**来说,加载伴随着零扩展(值在低位,高位填充零)

对于byte,short 来说,加载伴随着符号扩展,(保持符号位不变,低字节为值,高字节填充零)

#### 1.1.3 方法重载 与 重写

**方法重载**:

同一类中,方法名相同,参数类型不同(继承关系也算)

​	重载方法在编译时即可确认调用,过程有如下阶段:	

1. 不考虑自动拆装箱,可变长参数选取重载方法
2. 1步骤没找到,允许自动拆装箱,不允许可变长参数 选取重载
3. 2步骤没找到,允许自动拆装箱,允许可变长参数 选取重载.

如果在同一阶段找到了多个适配方法,那么会在其中按照形参的集成关系 来选取.

**方法重写**:

子类中定义与父类中同方法名,参数的方法

若子类重写父类的静态方法,子类中会隐藏父类的静态方法

若子类重写了父类的非静态,非私有方法,那么子类重写了父类的该方法.

注:重写是Java 多肽的一种重要体现方式.

#### 1.1.4 异常

**异常处理的两种方式:**

1. 抛出异常	抛出异常使用**throw** 关键字
2. 捕获异常    捕获异常使用 **try**{}**catch**(){}**finally**{} 三种代码块

**异常的基本概念:**

在JAVA 语言规范中,所有异常都是Throwable类或者子类的实例,Throwable 有两大子类.

1. Error     一般抛出Error 时,执行状态已经无法恢复,需要终止线程甚至是终止虚拟机.
2. Exception  程序需要捕获并且处理的异常

**Exception 划分:**

1. 编译期异常

   需要使用try,catch显示的捕获或者throws 关键字在方法声明中标注

2. 运行期异常

   RuntimeException

异常实例的构造十分昂贵,因为在构造异常实例时,JVM需要生成该异常的**栈轨迹** .该操作会注意访问当前线程的栈帧,并且记录下各种调试信息,包括栈帧所指向方法的名字,方法所在类,文件名,以及在触发异常的代码行数.(在生成栈轨迹时,JVM会忽略掉异常构造器以及填充栈帧的JAVA方法-Throwable.fillInStackTrace)

**JVM 是如何捕获异常的**

在编译生成的字节码中,每个方法都会附带一个异常表,如下

```java
    Exception table:
       from    to  target type
           6     8    13   Class java/lang/Exception
           6     8    22   any
          13    17    22   any
          22    24    22   any
```

异常表中的每一个条目代表一个异常处理器,并且由from指针,to指针,target指针 以及所捕获的异常类型构成

这些类型的值是字节码索引,用以定位字节码

当程序触发异常时,JVM 会从上至下遍历异常表中的条目,当触发异常的字节码的索引值在某一行的from,to 范围内时,JVM 会判断抛出的异常与 该条目捕获的异常是否匹配,若匹配,JVM将控制转移至该条目target指针指向的字节码.

若遍历完所有异常条目,JVM 仍未匹配到异常处理器,那么会弹出当前方法对应的JAVA 栈帧,并且在调用者(caller)中重复上述操作.最坏情况下,JVM 需要遍历当前线程JAVA 栈上的所有方法异常表.

finally 代码块的编译比较复杂,当前版本JAVA 编译器的做法是复制finally 代码块的内容,分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出后中.

注:若catch 代码块中捕获了异常,并且触发了另一个异常,那么finally 捕获并且重新抛出的是新的异常,原有的异常会被忽略掉.

**JAVA7 语法糖**

try-with-resources 语法糖,用来隐式的释放资源:

​	在try 关键字后声明并实例化实现了AutoCloseable 接口的类,编译器将自动添加对应的close 操作.



#### 1.1.* JDK 工具

|        |                                                           |
| ------ | --------------------------------------------------------- |
| jps    | 查看系统内所有JVM 进程                                    |
| jstat  | 收集jvm 各方面的运行数据                                  |
| jinfo  | 显示jvm 配置信息                                          |
| jmap   | 生成虚拟机内存快照 和 heapdump 文件                       |
| jhat   | 分析heapdump 文件,建立一个http 服务器,通过浏览器分析结果. |
| jstack | 显示虚拟机线程快照                                        |



### 1.2 Guava 基础

### 1.3 并发框架

### 1.4 JVM 相关

#### 1.4.1 JVM 启动参数

JVM 中启动参数共分为3类:

- **标准参数**             (  -  )	

  所有JVM 实现都必须实现这些参数的功能,并向后兼容

- **非标准参数**         ( -X )             

  默认jvm实现这些参数,但并不保证所有jvm 都满足,且不保证向后兼容

- **非Stable 参数**    (-XX)

  此类参数各个jvm 实现都会有所不同.可能会随时取消,需要慎重使用

**参考**

https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html

https://www.cnblogs.com/jack204/archive/2012/07/02/2572932.html

#### 1.4.2 JVM 运行时数据区规范

![img](resource\java-runtime-data-construct.png)

- **程序计数器**

  线程私有内存,用于存储线程间由于cpu 时间片执行,上下文切换后的恢复工作.不会出现`OutOfMemoryError`

- **堆**

  所有对象及数组均在堆上分配,堆是JVM 内存管理中最大的一块.

  会抛出`OutOfMemoryError: java heap space`  

  相关参数:

  ​	-Xms:1024M  Java heap 初始值 (server 端程序 将 -Xms  与 -Xmx 设置相同)

  ​	-Xmx:1024M  Java heap 最大值 (server 端程序 将 -Xms  与 -Xmx 设置相同) 默认物理内存1/4

  ​	-Xmn: 384M   Java heap eden 区大小. 此值对系统性能影像较大.官方推荐 整体堆的3/8.这个值变大, 

  ​	 老年代变小

- **Java 虚拟机栈**

  线程私有,生命周期 与 线程相同.描述java 方法执行的内存模型.用来执行方法.

  **栈帧**:java 方法执行时,会创建一个栈帧,存储**局部变量表**,**操作数栈**,**动态链接**,**方法出口**等信息.

  线程请求的栈深度大于虚拟机规定的深度,抛出`StackOverflowError` 

  在扩展栈的时候,如果无法申请到足够的内存,抛出`OutOfMemoryError`

  相关参数:

  ​	-Xss:1m	Java每个线程栈的大小.(-XX:ThreadStackSize 是某个jvm 版本的参数)

- **native 本地方法栈**

  执行虚拟机使用到的native 方法.同java 虚拟机栈一样,会抛出 `StackOverflowError` 或 `OutOfMemoryError`

- **方法区**

  又名**永久代**,用来存储JVM 中 已加载的类信息,常量,静态变量,会抛出 `OutOfMemoryError: PermGen Space` 

  运行时常量池,是方法区中的一部分,在类加载后,会把class 中的常量池放到运行时常量池中.

  **方法区的移除**: 从jdk1.7 开始,移除工作已经开始了,在jdk 1.8 中.将 类元数据 放到了本地内存中.将常量池 与 静态变量 放到java 堆里,jvm 将会为类的元数据明确分配和释放本地内存.这样就避免了原来 -XX:MaxPermSize 的限制,可以使用更多本地内存.在一定程度上解决了原有运行时生成大量类造成的`FullGC`

  **消除永久代的意义:**

  1. 字符串存放在永久代,容易出现性能问题和内存溢出
  2. 类及方法信息等难以确定大小.指定永久代大小困难.容易发生溢出 
  3. 永久代 为GC 带来复杂度.并且回收效率低
  4. Oracle 为了 HotSpot 与 JRockit 合并做准备

  相关参数:

  ​	-XX:PermSize=512m  -XX:MaxPermSize=512m 设置方法区大小 (jdk1.8 以前)

  ​	-XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m 设置元数据区大小 (jdk 1.8开始)

#### 1.4.3  Java 类加载机制

##### 1.4.3.1 **简介** 

​	查找类的字节码文件,并构造出在JVM 内部表示的对象组件.虚拟机把class 文件加载到内存,对数据进行校验,转换解析,初始化等

**类加载器:**

> BootStrap ClassLoader 启动类加载器,由C++实现,没有对应JAVA 对象(JRE lib 目录下jar,或-Xbootclasspath 指定的类)
>
> Extension ClassLoader 扩展类加载器 (JRE lib/ext 目录下的jar,或者由 java.ext.dirs 指定的类)
>
> ApplicationClassLoader 应用类加载器 (- classpath,系统变量java.class.path 或环境变量 CLASSPATH 所指定的路径)

除了BootStrap ClassLoader 加载器,其余类加载器都是 java.lang.ClassLoader 的子类,因此有对应的JAVA 	对象,这些类加载器需要先由另一个类加载器加载至JVM 中,才能执行类加载.

在JVM 中,类的唯一性是由类加载器实例,以及类的全名一同确定的,即便字节码相同,经不同类加载器加载,也会得到两个不同的类.(在大型应用中,借助这一特性,运行同一个类的不同版本)

注: 自定义类加载器,可以对class 文件进行加密,加载时,在利用自定义的类加载器对其解密.

##### 1.4.3.2 双亲委派

​	先检查是否加载过,若没有加载调用附加在其的loadClass,若父加载器为空,是用启动类加载器作为父加载器,如果父加载器加载失败.抛出ClassNotFoundException,则调用自己的findClass 方法进行加载.

为什么使用双亲委派:即防止内存中出现多份同样的字节码.安全上的考虑.

##### 1.4.3.3 类装载过程

1. 装载	

   查找,导入 class 文件,创建类的过程

2. 链接:把class 数据 合并到JVM 运行时数据区的过程

   a.校验:

   ​	检查载入class 数据的正确性

   b.准备:

   ​	给类的静态变量分配存储空间,设置默认值(非静态不在此时,静态常量值由代码决定)

   c.解析:

   ​	将符号引用转换成直接引用(JVM 将所有类,接口,字段,方法 转换为具体的内存地址),确保类之间的引用能够正确找到.  

   ​	解析过程中可能导致其他类执行加载过程.

3. 初始化

   对类的静态变量,静态代码执行初始化操作.

   一个类初始化之前,其直接父类业务被初始化.

   一个接口的初始化,不会引起其父接口的初始化,初始化的过程从上到下按顺序依次执行 静态代码 与 静态代码块

   JVM 规范枚举了如下种情况会触发初始化:

   - 虚拟机启动,初始化用户指定的主类
   - 新建目标类实例的new 指令时,初始化new 指定的目标类
   - 调用静态方法的指令时,初始化该静态方法所在的类
   - 调用静态字段的指令时,初始化该静态字段所在的类
   - 子类的初始化会触发父类的初始化
   - 一个接口定义了default 方法,直接或间接实现该接口的类的初始化,会触发该接口的初始化
   - 使用反射API对某个类进行反射调用时,初始化这个类
   - 当除此调用MethodHandle,初始化该MethodHandle 指向方法所在类(invoke dynamic)
##### 1.4.3.4 **JVM 是如何运行Java 字节码的**

​	从JVM 视角看,需要先按照上文描述的过程,将编译成的class 文件加载到jvm 中,加载后的java 类会存在方法区 中.实际运行时,虚拟机会执行方法区的方法

​	在运行时,每当调用一个Java 方法,JVM 会在当前线程的java 方法栈中生成一个栈帧,用来存放**局部变量** 以及 **字	节码操作数**,当退出执行方法时,无论执行成功失败,均会弹出当前线程栈帧.

硬件无法直接执行JAVA 字节码,JVM 需要将字节码翻译成机器代码.这个翻译过程有如下两种:

- 解释执行---无需等待编译
- 即时执行(Just-In-Time compilation ,JIT)---实际运行速度快

#### 1.4.4 JVM 的静态绑定和动态绑定

JVM 识别方法通过:**类名**,**方法名**,**方法描述符**.方法描述符由方法的**参数类型**以及**返回类型**所构成.

在同一个类中,如果同时出现**多个同名且同描述符的方法**,JVM 在类的验证阶段报错

JVM 与 JAVA  不一样,JVM 不限制 同名,同参数,但返回值不同的方法在同一类中.对于调用这些方法的字节码

字节码所附带的方法描述符包含了返回类型,所以JVM 可以准确识别目标方法.



JVM中关于重写的判定同样基于方法描述符,若子类定义了父类中非私有非静态的同名方法,只有当这两个方法的参数类型以及返回类型一致,JVM 才会认为是重写.

对于JAVA 中认为是重写,而JVM 中认定是非重写的情况,编译器会通过桥接方法来实现.

重载方法的区分在编译阶段已经完成.故可以认为在JVM 中不存在重载这一概念

在JVM 中有个不完全正确的说法:

​	重载:静态绑定,编译时多肽

​	重写:动态绑定,运行时多肽

这是因为,父类方法可能被子类方法重写,因此java 编译器将对所有非私有实例方法调用为动态绑定的类型.

#### 1.4.4 调用指定的符号引用

在编译过程中,不能确定目标方法的具体地址.因此JAVA 编译器会暂时使用符号引用来标识该目标方法.

符号引用:包括目标方法所在类或接口名字,目标方法的方法名和方法描述符

符号引用存储在class 文件的常量池中,根据目标方法是否为接口方法,引用可区分为 :**接口符号引用与非接口符号引用**

非接口符号引用:

​	假定该符号引用所指向的类C,则JVM 会按照如下步骤进行查找.

1. 在C 中查找符合名字以及描述符的方法

2. 如果没找到,在C 的父类中继续查找,直至Object类

3. 如果没找到,在C的直接实现或间接实现的接口中搜索,这一步搜索得到的目标方法必须是非私有,非静态的.并且,如果目标方法在间接实现的接口中,则需要满足C 与 该接口之间没有其他符合条件的目标方法.如果有多个符合的目标方法,任意返回其中一个.

   注:静态方法可以通过子类调用,子类的静态方法会覆盖父类的静态方法

接口符号引用:

​	假定该符号引用所指向的接口未I,则JVM 会按照如下步骤查找.

1. 在I中查找符合名字以及描述符的方法
2. 如果没找到,在Object 中的公有实例方法中搜索
3. 如果没找到,在I的超接口中搜索,过程与非接口符号引用的3一致

对于静态绑定的方法调用,实际引用是一个指向方法的指针.

对于动态绑定的方法调用,实际引用则是一个方发表的索引.

#### 1.4.4 虚方法,分派

java 字节码中调用方法的指令

| 名称            | 备注                                                         |
| --------------- | ------------------------------------------------------------ |
| invokestatic    | 调用静态方法                                                 |
| invokespecial   | 调用私有实例方法,new 关键字,super 关键字,所实现接口的默认方法 |
| invokeinterface | 调用接口方法                                                 |
| invokevirtual   | 调用非私有实例方法                                           |
| invokedynamic   | 调用动态方法(MethodHandle)                                   |

对于 invokestatic 与 invokespecial 来说JVM 能够直接识别目标方法

对于invokevirtual与 invokeinterface 来说JVM 需要在执行过程中根据调用者动态类型来执行具体目标方法.

在java 中,除了使用`final` `static` `private`  为非虚方法,其余均为虚方法

- 虚方法--动态绑定:

  虚方法调用通过invokevirtual,分两次分派,第一步在编译期看方法调用者和参数的静态类型,第二部在运行期只看方法调用者的动态类型.

- 非虚方法--静态绑定:

  对于非虚方法的调用,程序在编译阶段,就可以唯一确定一个可以调用的版本.并且这个方法在运行期不可改变,会在类加载的解析阶段,通过`invokestatic` `invokespecial` 指令将对非虚方法的符号引用转换为直接引用.

  非虚方法调用只看对象的静态类型(引用类型).

JVM 会采用空间换时间的策略来实现动态绑定,为每个类生成一个方发表,用以快速定位目标方法.

#### 1.4.5 方发表

在类加载的准备阶段,除了为静态字段分配内存,还会构造与该类关联的方发表

这个数据结构,是JVM 实现动态绑定的关键所在.下文中将用invokevirtual 锁使用的虚方法表(virtual method table vtable)为例介绍方发表用法,invokeinterface 所适用的接口方法表稍微复杂,原理类似.

方发表本质上是一个数组,每个数组元素指向一个当前类及其父类中非私有的实例方法.

这些方法可能是具体的可执行方法,也可能是没有相应字节码的抽象方法.方法表满足两个特质:

1. 子类方法表中包含父类方法表所有方法
2. 子类方法在方法表中的索引值,与它所重写的父类方法的索引值相同

上文中曾经说过,方法调用指令中的符号引用会在执行前解析成实际引用.对于静态绑定的方法调用,实际引用指向目标具体方法.对于动态绑定的方法调用,实际引用指向方法表的索引值(实际上 并不仅是索引值)

**动态绑定:**在实际实行过程中,JVM 将会获取调用者的实际类型,并在该实际类型的虚方法表中,根据索引值获得目标方法.

注: 实际上,使用了方法表的动态绑定与静态绑定相比,仅仅多出几个内存解引用操作:访问栈上的调用者,读取调用者的动态类型,读取该类型的方法表,读取方法表中某个索引值所对应的目标方法.但是,不能认同虚方法调用对性能没有太大影响,上述优化过程中仅存在与解释执行过程中,或即时编译最坏情况.即时编译还有另外两种性能更好的优化手段:内联缓存(inlining cache),方法内联(method inlining)

#### 1.4.6 内联缓存

内联缓存是一种加快动态绑定的优化技术,它能够缓存虚方法调用中调用者的动态类型,以及该类型所对应的目标方法.在之后的执行过程中,若碰到已缓存的类型,内联缓存变会直接调用该类型所对应的目标方法.若没有碰到已缓存的类型,内联缓存会退化至**基于方法表的动态绑定**

针对多态的优化手段中,通常涉及如下三个术语:

1. 单态	仅有一种状态
2. 多态    有限数量种状态的情况
3. 超多态 更多的状态情况,通常会有一个具体数值来区分多肽和超多态,数值下成为多态,反之

对于内联缓存来说分别对应了,单态,多态,超多态内联缓存.在实践中,大部分的虚方法调用时单态的,也就是只有一种动态类型,为了节省内存空间,JVM 只采用单态内联缓存.

当内联缓存没有命中的情况下,JVM 需要重新使用方法表进行动态绑定.对于内联缓存汇总的内容,有两种选择.

1. 替换单态内联缓存中的记录,但是在最坏情况下,我们使用两种不同的调用者,轮流执行该方法调用,那么每次进行方法调用都将替换内联缓存.只有写缓存的开销,但是缓存却没有利用上.
2. JVM 劣化为超多态,处于这种状态下的内联缓存,放弃了优化机会,将直接访问方法表,来动态绑定目标方法



注意:虽然内联缓存 有内联二字,但是它并没有内联目标方法.这里需要明确的是,任何方法调用除非被内联,否则都会有固定开销.这些开销来源于保存程序在该方法中执行位置,以及新建,压入和弹出新方法所使用的栈帧. 对于及其简单的方法而言,如getter/setter 这部分固定开销占据的CPU 时间甚至超过了方法本身.在即时编译中,方法内联不仅仅能够消除方法调用的固定开销,而且还增加了进一步优化的可能性.

#### 1.4.7 应用重启抖动

​	Java 程序在启动的时候,所有代码的执行处于解释执行模式,在运行一段时间后,根据代码执行次数,才会编译成机器代码.

​	**解决方式:**

​		1.程序主动预热: 启动完成后,主动访问热点代码.确保主要热点代码已经被编译成机器码后在放入流量.可以通

​			过`-XX:+PrintCompilation` 确认

​		2.复制流量预热,通过`tcpcopy`软件,拷贝一份线上nginx 流量进行预热,完成后在导入线上流量

​		3.启用多线程进行编译优化

### 1.5 垃圾回收

#### 1.5.1 判断对象是否存活

- **引用计数法**

  对象中添加引用计数器,有引用+1,引用失效-1.效率高,但难以处理对象互相引用的问题.

- **可达性分析**

  通过一些列`GC Roots` 的对象作为起点,向下搜索,搜索的路径为引用链,当一个对象到`GC Roots` 没有任何引用链相连接的时候,证明此对象是不可用的.

  可作为`GC Roots` 的对象:

  - 虚拟机栈中引用的对象
  - 方法区静态属性引用的对象
  - 方法区常量引用的对象
  - 本地方法栈中JNI 引用的对象

  在可达性分析中,不可达的对象也不一定是要死的.最少要被两次标记成不可达,第一次发现没有与`GC Roots`的引用链后,会被进行第一次标记,并进行第一次 筛选,筛选条件是是否有必要实行finalize 方法.

  **引用划分**:强引用,软引用,弱引用,虚引用 

#### 1.5.2 垃圾回收算法

##### 1.5.2.1 标记清除(Mark-Sweep)

分为**标记阶段**,**清除阶段**

![img](resource\garbage-collect-mark-sweep.png)

**缺点:** 

​	效率问题,标记与清除过程效率都不高

​	空间问题,会产生大量不连续的内存碎片,空间碎片太多可能导致在分配大对象时,找不到连续内存,提前触发GC

##### 1.5.2.2 复制(copying) 

解决标记清除效率问题.将内存按照容量划分成大小相等的两块,每次使用一块,对另一块进行内存回收,清除一整块空间,简单高效. **新生代一般采用此算法** eden 区会按照 8:1:1 划分成 eden 区,from survivor 区,to survivor 区,只用10% 来进行垃圾回收.

survivor 若空间没有足够内存存放存活对象时,会直接放进老年代.在eden 区中经过 N 次GC 的对象会迁移至老年代中. N 可配置.

![1577785888590](D:\idea code\selfcode\crazy_smn\doc\markdown\resource\garbage-collect-copying.png)

**缺点:**



##### 1.5.2.3 标记整理-压缩

分为**标记阶段**,**整理阶段**(让存活对象向其中一端移动,然后清除边界外的内存).一般用在老年代.

![1577786475220](resource\garbage-collect-mark.png)

##### 1.5.2.4 分代收集

**新生代:**  采用复制算法,一般一次可以回收 70%~95% 的空间

**老年代: ** 采用标记整理,或标记清除

#### 1.5.3 垃圾回收器

垃圾回收器类型:

- 串行回收,Serial 回收器,单线程回收,STW
- 并行回收,Parallel * 回收器,多线程回收.STW
- 并发回收,CMS 与 G1 ,多线程分阶段回收,只有某些特定阶段会 STW.

##### 1.5.3.1 Serial/Serial Old

​	Serial 复制算法					单线程	新生代	STW

​	Serial Old 标记整理算法	 单线程	老年代	STW

​	**相关参数:**

​			-XX:+UseSerialGC

##### 1.5.3.2 Throughput(默认)

​	**ParNew**

​	**Parallel Scavenge** 复制算法	多线程	新生代	STW

​	**Parallel Old** 标记整理算法		多线程	老年代	STW

​	**相关参数:**

​		-XX:+UseParallelGC  虚拟机运行在server 模式下的默认值,使用Parallel Scavenge+ Serail Old 组合

​		-XX:+UseParNewGC  启用ParNew + Serail Old 组合

​		-XX:+UseParallelOldGC 使用Parallel Scavenge + Parallel Old 的收集器组合

##### 1.5.3.3 CMS(Concurrent Mark Sweep)

​	CMS只会回收**老年代** 与 **方法区**(元数据区),不会收集**年轻代**

​	CMS是一种预处理垃圾回收器,它不能等到old 内存用尽时回收,需要在内存用尽前,完成回收工作,否则导致并发回	收失败;所以cms 垃圾回收器开始执行回收操作,有一个触发阈值,默认 老年代或 方法区 为 92%.

​	**使用场景:** 适合对延时要求较高的引用.用户线程下不允许长时间的停顿.

​	**缺点:**

​		服务长时间运行,造成严重的内存碎片化. 

​		对CPU 资源敏感,并发阶段虽然不会暂停用户线程,但会影像执行效率

​		无法处理浮动垃圾.

​		算法实现比较复杂.

​	**相关参数:**

​		-XX:+UseConcMarkSweepGC 开启CMS GC

​		-XX:+CMSClassUnloadingEnabled 开启元数据区垃圾回收

​		-XX:ParallelCMSThreads=	并发标记扫描垃圾回收器使用的线程数量

##### 1.5.3.4 G1(Garbage First)

​	`G1 GC`使用 并发 和 并行阶段实现其目标暂停时间,并保持良好的吞吐量,当`G1 GC`确定有必要执行垃圾回收时,会	先收集存活数据最少的区域.	

​	Garbage First 是一个横跨新生代和老年代的垃圾回收器,实际上,它已经打乱了前面所说的堆结构,直接将堆分成	及其多个区域,每个区域都可以充当Eden区,Survivor 区,或者老年代.采用的是标记压缩算法.

​	**相关参数:**

​		-XX:+UseG1GC

##### 1.5.3.5 内存分配 与 回收策略

- 对象优先在 新生代 Eden 分配,空间不足会触发 `Minor GC`,`Minor GC` 后空间 不足,通过**担保机制**进入老年代.

- 大对象直接进入老年代,避免短命大对象.可以使用 -XX:PretenureSizeThreshold 设置.仅在Serial 与ParNew 收集器有效.

- 长期存活的对象进入老年代,经过一次Minor GC 新生代的对象就会涨一岁.可以通过

  -XX:MaxTenuringThreshold

- **动态对象年龄判定**.针对小于MaxTenuringThreshold 的对象,如果survivor 中,年龄相同所有对象的大小总和大于Survivor 空间的一半,大于等于该年龄的对象可以直接进入老年代.

- **空间分配担保** 在`Minor GC` 前会检查,若老年代最大可用连续空间大于新生代总空间,`Minor GC` 是安全的.否则 根据`HandlePromotionFailer`  是否允许担保失败,可以的话会检查历史上最大可用连续空间是否大于晋升老年代对象的平均大小,如果大于,尝试进行一次有风险的`Minor GC`,小于或者不担保执行`FullGC`

##### 1.5.3.6 垃圾收集器参数

| 参数名                         | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | Client 模式下的默认值，使用Serial+SerialOld 的收集器组合进行回收 |
| UseParNewGC                    | ParNew + Serial Old 的收集器组合进行内存回收                 |
| UseConcMarkSweepGC             | ParNew + CMS + Serial Old 的收集器组合进行回收。Serial Old 作为 CMS 出现 Concurrent Mode Failure 失败后使用 |
| UseParallelGC                  | server 模式下的默认值，打开开关后，使用Parallel Scavenge +Serial Old 收集器组合进行回收 |
| UseParallelOldGC               | Parallel Scavenge + Parallel Old 的收集器组合进行内存回收。  |
| SurvivorRatio                  | 新生代Eden 与 survivor 区域的容量比例 默认 8:1               |
| PretenureSizeThreshold         | 直接晋升老年代的对象大小设置                                 |
| MaxTenuringThreshold           | 新生代晋升老年代年龄 值，当新生代年龄等于该值，晋升老年代    |
| UseAdaptiveSizePolicy          | 动态调整java 堆中 各个区域的大小，以及进入老年代的年龄       |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不够新生代的 Eden 与 Survivor 区的所有对象都存活的极端情况。 |
| ParallelGCThreads              | 设置并行GC 时进行内存回收的线程数                            |
| GCTimeRatio                    | GC时间占总时间的比率，默认 99 ，即仅允许1% 的GC 时间，只针对 Parallel Scavenge 收集器时生效 |
| MaxGCPauseMillis               | 设置GC 的最大停顿时间。尽在使用Parallel Scavenge 收集器时生效 |
| CMSInitiatingOccupancyFraction | 设置CMS 收集器在老年代空间在使用多少后出发垃圾回收，默认值68 |
| UseCMSCompactAtFullCollection  | 设置CMS 收集器在完成垃圾回收后是否进行一次内存碎片整理。     |
| CMSFullGCsBeforeCompaction     | 设置CMS 收集器在进行若干次 垃圾回收后，启动一次内存碎片整理。 |



## 常用框架

### Spring Framework

### SpringMVC

### Mybatis

### Guava

### SpringBoot

## Spring Cloud

### Eureka

### Ribbon

### Hystrix

### Feign

### Netflix Zull

### Spring Bus

### Spring Cloud Config

## 中间件

### zookeeper

### redis

### mysql

### rabbitmq

### keepalived

### openresty

### haproxy

### etcd

## 分布式

CAP

BASE

分布式锁

雪崩

高并发

CDN

