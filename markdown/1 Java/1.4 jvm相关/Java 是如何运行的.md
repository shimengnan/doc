# JVM 基础

## JAVA 是如何运行的

### JVM 具体是怎样运行 JAVA 字节码的

从虚拟机视角来看,执行java 代码,首先需要将它编译成的class文件加载到java 虚拟机中.加载后的java 类会存在方法区(Method Area) 中.实际运行时,虚拟机会执行方法区内的代码.

JVM 内存划分为:

- 线程共享:方法区
- 线程共享:堆
- 线程私有:程序计数器
- 线程私有:java 方法栈
- 线程私有:native 本地方法栈

在运行过程中,每当调用进入一个 JAVA 方法,Java 虚拟机会在当前线程的java方法栈中生成一个栈帧,用以存放局部变量以及字节码操作数.(JVM 不要求栈帧在内存空间连续分布).当退出当前执行的方法时,不管是正常返回还是异常返回,JVM 均会弹出当前线程栈帧.



硬件无法直接执行JAVA 字节码,JVM 需要将字节码翻译成机器代码.这个翻译过程有如下两种:

- 解释执行---无需等待编译
- 即时执行(Just-In-Time compilation ,JIT)---实际运行速度快

HotSpot默认采用混合模式,结合解释执行与即时执行的优点,先解释执行,而后将其中反复执行的热点代码,以方法为单位进行即时编译.

```
即时编译建立在程序符合二八定律的假设上,也就是百分制二十的代码占据了百分制八十的计算资源.对于占据大部分的不常用代码,无需耗时编译成机器代码,而是采取解释执行的方式运行,另一方面,对于仅占据一小部分热点代码,将其编译成机器代码,达到理想运行速度.
```

HotSpot 内置了多个即时编译器:C1,C2 和 Graal.Graal 是JAVA 10 引入的.

- C1 client 编译器		面向启动性能有要求的客户端GUI 程序
- C2 Server 编译器      面向对峰值性能有要求的服务器端程序,优化手段负责,编译时间长,执行效率高

从Java7 开始HotSpot 默认采用分层编译方式:热点方法首先会被C1 编译,而后热点方法会进一步被C2 编译

为了不干扰应用的正常运行,HotSpot 的即时编译是放在额外的编译线程中进行的.HotSpot会根据CPU 数量设置编译线程数目,并按照1:2比例分配给C1,C2.

#

